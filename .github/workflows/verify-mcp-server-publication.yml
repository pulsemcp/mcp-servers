name: Verify MCP Server Publication Staged

on:
  pull_request:
    paths:
      - 'experimental/*/local/package.json'
      - 'productionized/*/local/package.json'
      - '*/local/package.json'
      - 'README.md'

jobs:
  verify-publications:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Need full history to check for version changes

      - name: Fetch PR branch
        run: |
          git fetch origin pull/${{ github.event.pull_request.number }}/head:pr-branch
          echo "PR branch commits:"
          git log --oneline pr-branch | head -20

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v41
        with:
          files: |
            **/local/package.json

      - name: Verify each changed MCP server
        if: steps.changed-files.outputs.any_changed == 'true'
        run: |
          set -e

          echo "Changed package.json files: ${{ steps.changed-files.outputs.all_changed_files }}"

          # Track if any verification fails
          VERIFICATION_FAILED=false

          for file in ${{ steps.changed-files.outputs.all_changed_files }}; do
            echo "Checking $file"
            
            # Get the server directory (parent of local/)
            SERVER_DIR=$(dirname $(dirname "$file"))
            SERVER_NAME=$(basename "$SERVER_DIR")
            LOCAL_DIR="$SERVER_DIR/local"
            
            # Skip the template directory
            if [ "$SERVER_NAME" = "mcp-server-template" ] || [ "$SERVER_DIR" = "libs/mcp-server-template" ]; then
              echo "â„¹ï¸  Skipping mcp-server-template (template directory)"
              continue
            fi
            
            echo "Server: $SERVER_NAME"
            echo "Server directory: $SERVER_DIR"
            echo "Local directory: $LOCAL_DIR"
            
            # Get current version from package.json
            CURRENT_VERSION=$(node -e "console.log(require('./$LOCAL_DIR/package.json').version)")
            PACKAGE_NAME=$(node -e "console.log(require('./$LOCAL_DIR/package.json').name)")
            
            echo "Package: $PACKAGE_NAME@$CURRENT_VERSION"
            
            # Get base branch version
            git show origin/${{ github.base_ref }}:$file > base-package.json 2>/dev/null || echo '{"version": "0.0.0"}' > base-package.json
            BASE_VERSION=$(node -e "console.log(require('./base-package.json').version)")
            
            echo "Base version: $BASE_VERSION"
            echo "Current version: $CURRENT_VERSION"
            
            # Check if this is a new unpublished server
            IS_UNPUBLISHED=false
            if grep -qE "\|[[:space:]]*\[?$SERVER_NAME\]?.*\|[[:space:]]*Not Yet Published[[:space:]]*\|" README.md; then
              IS_UNPUBLISHED=true
              echo "â„¹ï¸  This is an unpublished server"
            fi
            
            # Check if version was bumped
            if [ "$CURRENT_VERSION" != "$BASE_VERSION" ]; then
              echo "âœ… Version was bumped from $BASE_VERSION to $CURRENT_VERSION"
              VERSION_BUMPED=true
            else
              echo "â„¹ï¸  Version unchanged at $CURRENT_VERSION"
              VERSION_BUMPED=false
            fi
            
            # Only check CHANGELOG and README if version was bumped
            if [ "$VERSION_BUMPED" = true ]; then
              # Check for CHANGELOG.md
              CHANGELOG_FILE="$SERVER_DIR/CHANGELOG.md"
              if [ ! -f "$CHANGELOG_FILE" ]; then
                echo "âŒ ERROR: No CHANGELOG.md found at $CHANGELOG_FILE"
                VERIFICATION_FAILED=true
                continue
              fi
              
              echo "âœ… CHANGELOG.md exists"
              
              # Check if CHANGELOG contains the new version
              if ! grep -q "## \[$CURRENT_VERSION\]" "$CHANGELOG_FILE"; then
                echo "âŒ ERROR: CHANGELOG.md does not contain entry for version $CURRENT_VERSION"
                echo "   Expected to find: ## [$CURRENT_VERSION]"
                VERIFICATION_FAILED=true
                continue
              fi
              
              echo "âœ… CHANGELOG.md contains entry for version $CURRENT_VERSION"
              
              # Check if README.md was updated with the new version
              echo "Checking if README.md was updated..."
              
              # Determine if this is experimental or productionized
              if [[ "$SERVER_DIR" == experimental/* ]]; then
                TABLE_SECTION="Experimental Servers"
              elif [[ "$SERVER_DIR" == productionized/* ]]; then
                TABLE_SECTION="Productionized Servers"
              else
                echo "âš ï¸  WARNING: Could not determine server type (experimental/productionized)"
                continue
              fi
              
              # Check if the server appears in README.md with the current version
              if [ "$IS_UNPUBLISHED" = true ]; then
                # For unpublished servers, we expect "Not Yet Published"
                if grep -qE "\|[[:space:]]*\[?$SERVER_NAME\]?.*\|[[:space:]]*Not Yet Published[[:space:]]*\|" README.md; then
                  echo "âœ… README.md correctly shows 'Not Yet Published' for unpublished server"
                else
                  echo "âŒ ERROR: README.md should show 'Not Yet Published' for unpublished server $SERVER_NAME"
                  VERIFICATION_FAILED=true
                  continue
                fi
              else
                # For published servers, we expect the version number
                if grep -qE "\|[[:space:]]*\[?$SERVER_NAME\]?.*\|[[:space:]]*$CURRENT_VERSION[[:space:]]*\|" README.md; then
                  echo "âœ… README.md contains entry for $SERVER_NAME with version $CURRENT_VERSION"
                else
                  # Check if it's incorrectly marked as "Not Yet Published"
                  if grep -qE "\|[[:space:]]*\[?$SERVER_NAME\]?.*\|[[:space:]]*Not Yet Published[[:space:]]*\|" README.md; then
                    echo "âŒ ERROR: README.md still shows 'Not Yet Published' for $SERVER_NAME"
                    echo "   Please update README.md to show version $CURRENT_VERSION"
                    VERIFICATION_FAILED=true
                    continue
                  else
                    echo "âŒ ERROR: README.md does not contain correct version for $SERVER_NAME"
                    echo "   Expected to find version $CURRENT_VERSION in the $TABLE_SECTION table"
                    VERIFICATION_FAILED=true
                    continue
                  fi
                fi
              fi
              
              # Check for git tag (only for published servers)
              if [ "$IS_UNPUBLISHED" = false ]; then
                EXPECTED_TAG="${PACKAGE_NAME}@${CURRENT_VERSION}"
                if git tag | grep -q "^${EXPECTED_TAG}$"; then
                  echo "âœ… Git tag exists: $EXPECTED_TAG"
                else
                  echo "âš ï¸  WARNING: Git tag not found: $EXPECTED_TAG"
                  echo "   Make sure to create and push the tag:"
                  echo "   git tag $EXPECTED_TAG"
                  echo "   git push origin $EXPECTED_TAG"
                fi
              else
                echo "â„¹ï¸  Git tag check skipped for unpublished server"
              fi
            else
              echo "â„¹ï¸  Skipping CHANGELOG/README checks - no version bump"
            fi
            
            # Check for manual test results if version was bumped
            if [ "$VERSION_BUMPED" = true ]; then
              MANUAL_TESTING_FILE="$SERVER_DIR/MANUAL_TESTING.md"
              if [ -f "$MANUAL_TESTING_FILE" ]; then
                echo "Checking manual test results..."
                
                # Get the commit hash from the PR
                PR_COMMIT="${{ github.event.pull_request.head.sha }}"
                PR_COMMIT_SHORT="${PR_COMMIT:0:7}"
                
                # Check if MANUAL_TESTING.md contains test results for a recent commit
                if grep -q "^\*\*Commit:" "$MANUAL_TESTING_FILE"; then
                  # Extract the commit hash from the file
                  TESTED_COMMIT=$(grep "^\*\*Commit:" "$MANUAL_TESTING_FILE" | sed 's/^\*\*Commit:\*\* *//' | cut -d' ' -f1)
                  TESTED_COMMIT_SHORT="${TESTED_COMMIT:0:7}"
                  
                  echo "Manual tests were run on commit: $TESTED_COMMIT_SHORT"
                  
                  # Check if the tested commit is in the PR's commit history
                  # First, try to check if the commit exists in the current git history
                  COMMIT_FOUND_IN_PR=false
                  
                  # Check if the tested commit exists and is in the PR branch
                  if git rev-list pr-branch | grep -q "^${TESTED_COMMIT}"; then
                    echo "âœ… Manual tests were run on a commit in this PR's history"
                    COMMIT_FOUND_IN_PR=true
                  else
                    # Fallback: check with short SHA
                    if git rev-list pr-branch | grep -q "^${TESTED_COMMIT_SHORT}"; then
                      echo "âœ… Manual tests were run on a commit in this PR's history"
                      COMMIT_FOUND_IN_PR=true
                    else
                      echo "âŒ ERROR: Manual tests were run on commit $TESTED_COMMIT_SHORT"
                      echo "   This commit is not in the current PR's history"
                      echo "   Available commits in PR:"
                      git log --oneline pr-branch | head -10
                      echo ""
                      echo "   ðŸš¨ IMPORTANT: Update the commit reference in the 'Latest Test Results' section"
                      echo "   This script checks the FIRST **Commit:** line in MANUAL_TESTING.md (around line 9)"
                      echo "   NOT the one in the 'Manual Test Results' section at the bottom of the file"
                      echo ""
                      echo "   To fix: Update the **Commit:** field in the 'Latest Test Results' section to reference"
                      echo "   ANY existing commit from the PR history shown above (pick any commit hash from the list)"
                      VERIFICATION_FAILED=true
                    fi
                  fi
                  
                  # Check test results if commit was found
                  if [ "$COMMIT_FOUND_IN_PR" = true ]; then
                    # Check test results (but don't fail if tests didn't pass)
                    if grep -q "**Overall:**.* 100%" "$MANUAL_TESTING_FILE" || grep -q "All manual tests passed" "$MANUAL_TESTING_FILE"; then
                      echo "âœ… Manual tests passed"
                    else
                      echo "â„¹ï¸  Manual tests did not achieve 100% pass rate"
                      echo "   Review MANUAL_TESTING.md for details"
                    fi
                  fi
                else
                  echo "âŒ ERROR: MANUAL_TESTING.md exists but doesn't contain test results"
                  echo "   Please run manual tests and document the results"
                  VERIFICATION_FAILED=true
                fi
              else
                echo "â„¹ï¸  No MANUAL_TESTING.md found - manual tests may not be applicable"
              fi
            fi
            
            # Run tests for this server
            echo "Running tests for $SERVER_NAME..."
            cd "$SERVER_DIR"
            
            # Install dependencies - use ci:install if available, otherwise npm install
            if npm run --silent ci:install 2>/dev/null; then
              echo "âœ… Dependencies installed with ci:install"
            else
              echo "â„¹ï¸  No ci:install script found, using npm install"
              npm install
            fi
            
            # Run build
            if npm run build; then
              echo "âœ… Build succeeded"
            else
              echo "âŒ ERROR: Build failed"
              VERIFICATION_FAILED=true
            fi
            
            # Run tests (if they exist)
            if npm test; then
              echo "âœ… Tests passed"
            else
              echo "âŒ ERROR: Tests failed or no tests found"
              VERIFICATION_FAILED=true
            fi

            # Validate npm package can be executed via npx
            echo "Validating npm package executability..."
            cd "$LOCAL_DIR"

            # Get the bin entry from package.json
            BIN_NAME=$(node -e "const pkg = require('./package.json'); const bin = pkg.bin; if (typeof bin === 'string') { console.log(pkg.name); } else if (bin) { console.log(Object.keys(bin)[0]); }")

            if [ -z "$BIN_NAME" ]; then
              echo "â„¹ï¸  No bin entry found, skipping npx validation"
            else
              echo "Validating executable: $BIN_NAME"

              # Run prepublishOnly script first (npm pack doesn't run it, only npm publish does)
              # This prepares the shared files for packaging
              PREPUBLISH_SCRIPT=$(node -e "const pkg = require('./package.json'); console.log(pkg.scripts?.prepublishOnly || '')")
              if [ -n "$PREPUBLISH_SCRIPT" ]; then
                echo "Running prepublishOnly script: $PREPUBLISH_SCRIPT"
                npm run prepublishOnly
              fi

              # Run npm pack to create the tarball
              echo "Running npm pack..."
              TARBALL=$(npm pack 2>&1 | tail -1)

              if [ ! -f "$TARBALL" ]; then
                echo "âŒ ERROR: npm pack failed to create tarball"
                VERIFICATION_FAILED=true
              else
                echo "âœ… Created tarball: $TARBALL"

                # Create a temporary directory and install the package
                TEST_DIR=$(mktemp -d)
                echo "Testing in: $TEST_DIR"

                cd "$TEST_DIR"
                npm init -y > /dev/null 2>&1
                npm install "$OLDPWD/$TARBALL" 2>&1

                # Check if the binary was installed
                if [ -f "node_modules/.bin/$BIN_NAME" ]; then
                  echo "âœ… Binary installed at node_modules/.bin/$BIN_NAME"

                  # Try to execute the binary (it should at least start and show an error about missing env vars)
                  # We use timeout to prevent hanging and expect a non-zero exit code (due to missing config)
                  set +e
                  OUTPUT=$(timeout 5s ./node_modules/.bin/$BIN_NAME 2>&1)
                  EXIT_CODE=$?
                  set -e

                  # Check if it ran (exit code 1 with output is OK - means it executed but needs config)
                  # Exit code 127 means "command not found" which is the failure we want to catch
                  # Also check for ERR_MODULE_NOT_FOUND which means shared files weren't bundled
                  if [ $EXIT_CODE -eq 127 ]; then
                    echo "âŒ ERROR: Binary failed with 'command not found' (exit code 127)"
                    echo "   This usually means the shebang is missing or the package files are incomplete"
                    echo "   Output: $OUTPUT"
                    VERIFICATION_FAILED=true
                  elif echo "$OUTPUT" | grep -q "ERR_MODULE_NOT_FOUND"; then
                    echo "âŒ ERROR: Binary failed with module not found error"
                    echo "   This usually means the shared files weren't included in the package"
                    echo "   Output: $OUTPUT"
                    VERIFICATION_FAILED=true
                  elif [ $EXIT_CODE -eq 124 ]; then
                    # Timeout - might mean it's waiting for input, which is acceptable
                    echo "âœ… Binary executed (timed out waiting for input, which is acceptable)"
                  else
                    echo "âœ… Binary executed successfully (exit code: $EXIT_CODE)"
                    echo "   Output preview: $(echo "$OUTPUT" | head -3)"
                  fi
                else
                  echo "âŒ ERROR: Binary not found at node_modules/.bin/$BIN_NAME"
                  echo "   Contents of node_modules/.bin:"
                  ls -la node_modules/.bin/ 2>/dev/null || echo "   (directory does not exist)"
                  VERIFICATION_FAILED=true
                fi

                # Cleanup
                cd "$OLDPWD"
                rm -rf "$TEST_DIR"
                rm -f "$TARBALL"
                # Clean up prepublishOnly artifacts (shared dir and README copied during prepare)
                rm -rf shared README.md 2>/dev/null || true
              fi
            fi

            cd - > /dev/null

            echo "---"
          done

          # Clean up
          rm -f base-package.json

          if [ "$VERIFICATION_FAILED" = true ]; then
            echo "âŒ Verification failed for one or more servers"
            exit 1
          else
            echo "âœ… All servers passed verification"
          fi

      - name: Summary
        if: always()
        run: |
          echo "## MCP Server Publication Verification Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.changed-files.outputs.any_changed }}" == "true" ]; then
            echo "### Checked Servers:" >> $GITHUB_STEP_SUMMARY
            for file in ${{ steps.changed-files.outputs.all_changed_files }}; do
              SERVER_DIR=$(dirname $(dirname "$file"))
              SERVER_NAME=$(basename "$SERVER_DIR")
              echo "- $SERVER_NAME" >> $GITHUB_STEP_SUMMARY
            done
          else
            echo "No MCP server package.json files were modified." >> $GITHUB_STEP_SUMMARY
          fi
