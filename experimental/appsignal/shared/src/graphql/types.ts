/**
 * THIS FILE IS AUTOGENERATED.
 * DO NOT EDIT MANUALLY.
 * Generated from AppSignal GraphQL schema using graphql-codegen.
 */

export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  DateTime: { input: any; output: any; }
  JSON: { input: any; output: any; }
  PreciseDateTime: { input: any; output: any; }
};

export type ActionLink = {
  __typename?: 'ActionLink';
  sourceAction: ActionLinkAction;
  sourceApp: App;
  targetAction: ActionLinkAction;
  targetApp: App;
};

export type ActionLinkAction = {
  __typename?: 'ActionLinkAction';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  namespace: Scalars['String']['output'];
};

/**
 * A list of fields to return.
 *
 * Example:
 *
 * "fields": [
 *   {"field": COUNT, "aggregate": SUM},
 *   {"field": P90,   "aggregate", AVG}
 * ]
 *
 */
export type AggregateField = {
  /** Aggregation to perform (SUM, AVG, MIN and MAX) */
  aggregate: MetricAggregateEnum;
  /** Name of field to return (MEAN, COUNT, P90, P95 and gauge) */
  field: MetricFieldEnum;
};

/** Aggregation of metrics grouped by tags */
export type AggregationList = {
  __typename?: 'AggregationList';
  /** End time of performed metric query */
  end: Scalars['DateTime']['output'];
  /** Rows returned for aggregated list */
  rows?: Maybe<Array<AggregationListRow>>;
  /** Start time of performed metric query */
  start: Scalars['DateTime']['output'];
  /** Total keys found for query, only populated when $offset is 0 */
  total?: Maybe<Scalars['Int']['output']>;
};

/** Row with grouped aggregation list data */
export type AggregationListRow = {
  __typename?: 'AggregationListRow';
  /** List of fields with value for metric */
  fields?: Maybe<Array<KeyFloatValue>>;
  /** ID of metric */
  id: Scalars['String']['output'];
  /** Name of metric */
  name: Scalars['String']['output'];
  /** List of tags for metric */
  tags?: Maybe<Array<KeyStringValue>>;
};

/** Alert triggered by metrics monitor */
export type Alert = {
  __typename?: 'Alert';
  /** Time at which the alert was closed after cooling down. Is 'null' if still open. */
  closedAt?: Maybe<Scalars['DateTime']['output']>;
  /** (optional) Reason alert was closed */
  closedReason?: Maybe<Scalars['String']['output']>;
  /** Time at which an alert was created. The condition for the parent Trigger was met at this time. */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** Time at which the first notification was sent. */
  firstNotifiedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Triggered Alert ID */
  id: Scalars['String']['output'];
  /** Time at which the alert was last processed. */
  lastProcessedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Last value that triggered the alert */
  lastValue: Scalars['Float']['output'];
  /** Mean value during alert */
  mean: Scalars['Float']['output'];
  /** (optional) Message */
  message?: Maybe<Scalars['String']['output']>;
  /** Digest of metric that triggered the alert */
  metricDigest: Scalars['String']['output'];
  /** Time at which the alert was opened after warming up. */
  openedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Peak value during alert */
  peakValue: Scalars['Float']['output'];
  /** Time at which the alert was resolved before cooling down. Can be reopened if occurred during cooldown. Is 'null' if still open or warming up. */
  resolvedAt?: Maybe<Scalars['DateTime']['output']>;
  /** The current alert state */
  state: AlertStateEnum;
  /** List of state changes */
  stateChanges?: Maybe<Array<AlertStateChange>>;
  /** List of tags */
  tags?: Maybe<Array<KeyStringValue>>;
  /** End of timeframe for alert data */
  timeframeEndAt?: Maybe<Scalars['DateTime']['output']>;
  /** Start of timeframe for alert data */
  timeframeStartAt?: Maybe<Scalars['DateTime']['output']>;
  /** Alert trigger that triggered this alert */
  trigger: Trigger;
  /** Version of alert */
  version: Scalars['Int']['output'];
};

/** State changes for an alert */
export type AlertStateChange = {
  __typename?: 'AlertStateChange';
  /** The current alert state */
  state: AlertStateEnum;
  /** Time the state was changed */
  time?: Maybe<Scalars['DateTime']['output']>;
  /** Last value that triggered the alert */
  value?: Maybe<Scalars['Float']['output']>;
};

export enum AlertStateEnum {
  Archived = 'ARCHIVED',
  Closed = 'CLOSED',
  Cooldown = 'COOLDOWN',
  Open = 'OPEN',
  Untracked = 'UNTRACKED',
  Warmup = 'WARMUP'
}

/** Anomaly incident in which a problem or exception was reported */
export type AnomalyIncident = IncidentInterface & {
  __typename?: 'AnomalyIncident';
  /** Alert that was triggered by this incident */
  alert?: Maybe<Alert>;
  /** Alert state of this incident */
  alertState?: Maybe<AlertStateEnum>;
  /** Alerts that were triggered by this incident */
  alerts?: Maybe<Array<Maybe<Alert>>>;
  /** App in which the incident occurred */
  app?: Maybe<App>;
  /** Users assigned to investigate or resolve this incident */
  assignees?: Maybe<Array<Maybe<User>>>;
  /** Total count of all recorded requests/jobs for this incident */
  count: Scalars['Int']['output'];
  /** Create time of incident */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** Incident description, or steps to solve the issue */
  description?: Maybe<Scalars['String']['output']>;
  /** All incident digests */
  digests?: Maybe<Array<Scalars['String']['output']>>;
  /** Incident ID */
  id: Scalars['String']['output'];
  /** List of available integration types */
  integrations?: Maybe<Array<Maybe<Integration>>>;
  /** Time incident last occurred at */
  lastOccurredAt?: Maybe<Scalars['DateTime']['output']>;
  /** Logbook for incident */
  logbook: Logbook;
  /** Notification frequency for incident */
  notificationFrequency?: Maybe<IncidentNotificationFrequencyEnum>;
  /** Incident number */
  number: Scalars['Int']['output'];
  /** Severity of incident (critical/high/low/etc.) */
  severity?: Maybe<IncidentSeverityEnum>;
  /** State of incident (open/closed) */
  state?: Maybe<IncidentStateEnum>;
  /** Incident summary */
  summary?: Maybe<Scalars['String']['output']>;
  /** Tags of metric that matches this triggered incident */
  tags?: Maybe<Array<KeyStringValue>>;
  /** Trigger that triggered this incident */
  trigger?: Maybe<Trigger>;
  /** Last update time of incident */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};


/** Anomaly incident in which a problem or exception was reported */
export type AnomalyIncidentAlertArgs = {
  id: Scalars['String']['input'];
};


/** Anomaly incident in which a problem or exception was reported */
export type AnomalyIncidentAlertsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  state?: InputMaybe<AlertStateEnum>;
};

/** An AppSignal app */
export type App = {
  __typename?: 'App';
  /** Linked apps through distributed tracing */
  actionLinks?: Maybe<Array<Maybe<ActionLink>>>;
  /** List triggered alerts */
  alerts?: Maybe<Array<Maybe<Alert>>>;
  anomalyIncidents?: Maybe<Array<Maybe<AnomalyIncident>>>;
  /** Backtrace for the given ID */
  backtrace?: Maybe<Array<Maybe<BacktraceLine>>>;
  /** Check-in-related queries */
  checkIns?: Maybe<CheckIns>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  dashboard?: Maybe<Dashboard>;
  dashboards?: Maybe<Array<Maybe<Dashboard>>>;
  /** List of deploy markers */
  deployMarkers?: Maybe<Array<Maybe<DeployMarker>>>;
  /** App environment */
  environment: Scalars['String']['output'];
  /** TEMPORARY, DO NOT USE. Event */
  event?: Maybe<Event>;
  /** TEMPORARY, DO NOT USE. (top) list of event group metrics (e.g. active_record) */
  eventGroupList?: Maybe<AggregationList>;
  exceptionIncidents?: Maybe<Array<Maybe<ExceptionIncident>>>;
  /** Front-End API key */
  frontendApiKey: Scalars['String']['output'];
  /** Getting started items */
  gettingStartedItems: Array<Maybe<Item>>;
  /** App ID */
  id: Scalars['String']['output'];
  incident?: Maybe<Incident>;
  /** List of all incidents (Exception and Performance) */
  incidents?: Maybe<Array<Maybe<Incident>>>;
  /** Linked apps through distributed tracing */
  links?: Maybe<Array<Maybe<Link>>>;
  logIncidents?: Maybe<Array<Maybe<LogIncident>>>;
  logView?: Maybe<View>;
  logViews?: Maybe<Array<Maybe<View>>>;
  /** Log-related queries */
  logs?: Maybe<Logs>;
  /** Single marker of any type, by id */
  marker?: Maybe<MarkerUnion>;
  /** List of all marker types (Deploy/Notification/Custom) */
  markers?: Maybe<Array<Maybe<MarkerUnion>>>;
  /** Metrics for app, (timelines/lists/gauges) */
  metrics?: Maybe<Metrics>;
  /** App name */
  name: Scalars['String']['output'];
  /** List of seen namespaces */
  namespaces?: Maybe<Array<Scalars['String']['output']>>;
  /** List of available 3rd party notifiers */
  notifiers?: Maybe<Array<Maybe<Notifier>>>;
  /** Organization that this app belongs to. */
  organization?: Maybe<Organization>;
  paginatedAnomalyIncidents?: Maybe<PaginatedAnomalyIncidents>;
  paginatedExceptionIncidents?: Maybe<PaginatedExceptionIncidents>;
  paginatedLogIncidents?: Maybe<PaginatedLogIncidents>;
  paginatedPerformanceIncidents?: Maybe<PaginatedPerformanceIncidents>;
  performanceIncidents?: Maybe<Array<Maybe<PerformanceIncident>>>;
  /** List of seen platforms */
  platforms?: Maybe<Array<Scalars['String']['output']>>;
  /** Push API key (Heroku apps only) (internal use only, might be removed) */
  pushApiKey: Scalars['String']['output'];
  /** Span-related queries */
  spans?: Maybe<Spans>;
  /** App status */
  status: Scalars['String']['output'];
  /** List of time detective data points that occurred within a specific time. */
  timeDetectiveErrorDataPoints?: Maybe<Array<Maybe<TimeDetectiveDataPoint>>>;
  /** List of time detective data points that occurred within a specific time. */
  timeDetectivePerformanceDataPoints?: Maybe<Array<Maybe<TimeDetectiveDataPoint>>>;
  /** Find a single trigger. */
  trigger?: Maybe<Trigger>;
  /** List alert triggers for apps. */
  triggers?: Maybe<Array<Maybe<Trigger>>>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  uptimeMonitor?: Maybe<UptimeMonitor>;
  /** List of available uptime monitor regions */
  uptimeMonitorRegions?: Maybe<Array<Maybe<UptimeMonitorRegion>>>;
  /** List of uptime monitors for app. */
  uptimeMonitors?: Maybe<Array<Maybe<UptimeMonitor>>>;
  users?: Maybe<Array<Maybe<User>>>;
  viewerPinned?: Maybe<Scalars['Boolean']['output']>;
};


/** An AppSignal app */
export type AppActionLinksArgs = {
  end?: InputMaybe<Scalars['DateTime']['input']>;
  sourceAppId: Scalars['String']['input'];
  start?: InputMaybe<Scalars['DateTime']['input']>;
  targetAppId: Scalars['String']['input'];
  timeframe?: InputMaybe<TimeframeEnum>;
};


/** An AppSignal app */
export type AppAlertsArgs = {
  end?: InputMaybe<Scalars['DateTime']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  start?: InputMaybe<Scalars['DateTime']['input']>;
  state?: InputMaybe<AlertStateEnum>;
};


/** An AppSignal app */
export type AppAnomalyIncidentsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<IncidentOrderEnum>;
  state?: InputMaybe<IncidentStateEnum>;
};


/** An AppSignal app */
export type AppBacktraceArgs = {
  id: Scalars['String']['input'];
  revision: Scalars['String']['input'];
};


/** An AppSignal app */
export type AppDashboardArgs = {
  id: Scalars['String']['input'];
};


/** An AppSignal app */
export type AppDeployMarkersArgs = {
  dummy?: InputMaybe<Scalars['Boolean']['input']>;
  end?: InputMaybe<Scalars['DateTime']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  revisions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  start?: InputMaybe<Scalars['DateTime']['input']>;
};


/** An AppSignal app */
export type AppEventArgs = {
  digest: Scalars['String']['input'];
};


/** An AppSignal app */
export type AppEventGroupListArgs = {
  end?: InputMaybe<Scalars['DateTime']['input']>;
  groups: Array<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['DateTime']['input']>;
  timeframe?: InputMaybe<TimeframeEnum>;
};


/** An AppSignal app */
export type AppExceptionIncidentsArgs = {
  actionName?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  marker?: InputMaybe<Scalars['String']['input']>;
  namespaces?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<IncidentOrderEnum>;
  state?: InputMaybe<IncidentStateEnum>;
};


/** An AppSignal app */
export type AppIncidentArgs = {
  incidentNumber: Scalars['Int']['input'];
};


/** An AppSignal app */
export type AppIncidentsArgs = {
  actionName?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  marker?: InputMaybe<Scalars['String']['input']>;
  namespaces?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<IncidentOrderEnum>;
  state?: InputMaybe<IncidentStateEnum>;
};


/** An AppSignal app */
export type AppLinksArgs = {
  end?: InputMaybe<Scalars['DateTime']['input']>;
  start?: InputMaybe<Scalars['DateTime']['input']>;
  timeframe?: InputMaybe<TimeframeEnum>;
};


/** An AppSignal app */
export type AppLogIncidentsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<IncidentOrderEnum>;
  state?: InputMaybe<IncidentStateEnum>;
};


/** An AppSignal app */
export type AppLogViewArgs = {
  id: Scalars['String']['input'];
};


/** An AppSignal app */
export type AppMarkerArgs = {
  id: Scalars['String']['input'];
};


/** An AppSignal app */
export type AppMarkersArgs = {
  end?: InputMaybe<Scalars['DateTime']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  start?: InputMaybe<Scalars['DateTime']['input']>;
};


/** An AppSignal app */
export type AppPaginatedAnomalyIncidentsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<IncidentOrderEnum>;
  state?: InputMaybe<IncidentStateEnum>;
};


/** An AppSignal app */
export type AppPaginatedExceptionIncidentsArgs = {
  actionName?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  marker?: InputMaybe<Scalars['String']['input']>;
  namespaces?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<IncidentOrderEnum>;
  state?: InputMaybe<IncidentStateEnum>;
};


/** An AppSignal app */
export type AppPaginatedLogIncidentsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<IncidentOrderEnum>;
  state?: InputMaybe<IncidentStateEnum>;
};


/** An AppSignal app */
export type AppPaginatedPerformanceIncidentsArgs = {
  actionName?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  marker?: InputMaybe<Scalars['String']['input']>;
  namespaces?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<IncidentOrderEnum>;
  state?: InputMaybe<IncidentStateEnum>;
};


/** An AppSignal app */
export type AppPerformanceIncidentsArgs = {
  actionName?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  marker?: InputMaybe<Scalars['String']['input']>;
  namespaces?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<IncidentOrderEnum>;
  state?: InputMaybe<IncidentStateEnum>;
};


/** An AppSignal app */
export type AppTimeDetectiveErrorDataPointsArgs = {
  end: Scalars['DateTime']['input'];
  namespaces: Array<InputMaybe<Scalars['String']['input']>>;
  start: Scalars['DateTime']['input'];
};


/** An AppSignal app */
export type AppTimeDetectivePerformanceDataPointsArgs = {
  end: Scalars['DateTime']['input'];
  namespaces: Array<InputMaybe<Scalars['String']['input']>>;
  start: Scalars['DateTime']['input'];
};


/** An AppSignal app */
export type AppTriggerArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
};


/** An AppSignal app */
export type AppUptimeMonitorArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
};

export type Asana = IntegrationInterface & {
  __typename?: 'Asana';
  /** Form data fields for Asana integration */
  formData?: Maybe<AsanaFormData>;
  /** Integration title */
  name: Scalars['String']['output'];
  /** Set to true if the integration needs a migration */
  needsMigration: Scalars['Boolean']['output'];
  /** List of Asana tasks */
  tasks: Array<Maybe<AsanaTask>>;
};

export type AsanaFormData = IntegrationFormDataInterface & {
  __typename?: 'AsanaFormData';
  /** Body */
  body: Scalars['String']['output'];
  /** Title */
  title: Scalars['String']['output'];
};

export type AsanaTask = IntegrationResultInterface & {
  __typename?: 'AsanaTask';
  /** Description provided by the AppSignal user */
  description: Scalars['String']['output'];
  /** Integration result ID */
  id: Scalars['String']['output'];
  /** Remote ID of integration (e.g. GitHub issue number or Asana ID */
  remoteId: Scalars['String']['output'];
  /** Title provided by the AppSignal user */
  title: Scalars['String']['output'];
  /** Url to remote integration */
  url: Scalars['String']['output'];
};

export type AssigneeChange = ItemInterface & {
  __typename?: 'AssigneeChange';
  /** Added assignees */
  addedAssignees: Array<User>;
  /** User that created the change. If empty, the user was deleted. */
  author?: Maybe<User>;
  /** Time at which the change was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Current assignees */
  currentAssignees: Array<User>;
  /** Change ID. */
  id: Scalars['String']['output'];
  /** Previous assignees */
  previousAssignees: Array<User>;
  /** Removed assignees */
  removedAssignees: Array<User>;
  /** Time at which the change was updated last. */
  updatedAt: Scalars['DateTime']['output'];
};

export type BacktraceLine = {
  __typename?: 'BacktraceLine';
  /** Backtrace surrounding code */
  code?: Maybe<Array<Maybe<Code>>>;
  /** Backtrace column number */
  column?: Maybe<Scalars['String']['output']>;
  /** Backtrace line parse error */
  error?: Maybe<Error>;
  /** Backtrace line number */
  line?: Maybe<Scalars['String']['output']>;
  /** Backtrace method */
  method?: Maybe<Scalars['String']['output']>;
  /** Original (unparsed) line */
  original?: Maybe<Scalars['String']['output']>;
  /** Backtrace path */
  path?: Maybe<Scalars['String']['output']>;
  /** Backtrace type, (line/app) */
  type?: Maybe<Scalars['String']['output']>;
  /** Backtrace url */
  url?: Maybe<Scalars['String']['output']>;
};

/** Breadcrumb belonging to a sample */
export type Breadcrumb = {
  __typename?: 'Breadcrumb';
  /** Action performed to create breadcrumb (e.g The user clicked a button) */
  action: Scalars['String']['output'];
  /** Category (e.g. Network) */
  category: Scalars['String']['output'];
  /** Log message */
  message?: Maybe<Scalars['String']['output']>;
  /** Metadata recorded when breadcrumb was created. */
  metadata?: Maybe<Array<Maybe<KeyStringValue>>>;
  /** Time of breadcrumb creation */
  time?: Maybe<Scalars['DateTime']['output']>;
};

export type BulkTimeseries = {
  __typename?: 'BulkTimeseries';
  /** List if series used for metrics */
  series: Array<Series>;
  /** List of values to plot */
  values: Array<Values>;
};

export type CheckIn = {
  __typename?: 'CheckIn';
  /** Actual duration of the run in milliseconds */
  actualDuration?: Maybe<Scalars['Int']['output']>;
  /** Actual finish time */
  actualEnd?: Maybe<Scalars['DateTime']['output']>;
  /** Actual start time */
  actualStart?: Maybe<Scalars['DateTime']['output']>;
  /** Expected duration of the run in milliseconds */
  expectedDuration?: Maybe<Scalars['Int']['output']>;
  /** Expected finish time */
  expectedEnd: Scalars['DateTime']['output'];
  /** Expected start time */
  expectedStart: Scalars['DateTime']['output'];
  /** ID of the run */
  id: Scalars['String']['output'];
  /** State of the check-in */
  state: CheckInStateEnum;
  /** updates */
  updates?: Maybe<Array<CheckInUpdate>>;
};

export enum CheckInKindEnum {
  Finish = 'FINISH',
  Start = 'START'
}

export enum CheckInStateEnum {
  Finished = 'FINISHED',
  Late = 'LATE',
  Missed = 'MISSED',
  New = 'NEW',
  Started = 'STARTED',
  Unexpected = 'UNEXPECTED'
}

export type CheckInTrigger = {
  __typename?: 'CheckInTrigger';
  checkIn?: Maybe<CheckIn>;
  checkIns?: Maybe<Array<CheckIn>>;
  /** Description of the heartbeat trigger */
  description?: Maybe<Scalars['String']['output']>;
  /** ID of the check-in trigger */
  id: Scalars['String']['output'];
  /** Identifier of the check-in trigger */
  identifier: Scalars['String']['output'];
  /** Kind of check-in trigger */
  kind: CheckInTriggerKindEnum;
  /** Last error time, if present */
  lastErrorAt?: Maybe<Scalars['DateTime']['output']>;
  /** State of the last received check-in */
  lastState: CheckInStateEnum;
  /** Last success time, if present */
  lastSuccessAt?: Maybe<Scalars['DateTime']['output']>;
  /** Last update time, if present */
  lastUpdateAt?: Maybe<Scalars['DateTime']['output']>;
  /** Logbook for trigger */
  logbook: Logbook;
  notifiers?: Maybe<Array<Notifier>>;
  /** Cron syntax */
  syntax?: Maybe<Scalars['String']['output']>;
  /** Timezone */
  timezone: Scalars['String']['output'];
  /** Wait time in minutes */
  waitTimeMinutes: Scalars['Int']['output'];
};


export type CheckInTriggerCheckInArgs = {
  id: Scalars['String']['input'];
};


export type CheckInTriggerCheckInsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  states?: InputMaybe<Array<CheckInStateEnum>>;
};

export enum CheckInTriggerKindEnum {
  Cron = 'CRON',
  Heartbeat = 'HEARTBEAT'
}

export type CheckInUpdate = {
  __typename?: 'CheckInUpdate';
  /** Digest provided by the user */
  digest?: Maybe<Scalars['String']['output']>;
  /** Check-in kind */
  kind: CheckInKindEnum;
  /** Timestamp of check-in */
  timestamp: Scalars['DateTime']['output'];
};

export type CheckIns = {
  __typename?: 'CheckIns';
  /** Check-in trigger by id */
  trigger?: Maybe<CheckInTrigger>;
  /** List of check-in triggers */
  triggers?: Maybe<Array<CheckInTrigger>>;
};


export type CheckInsTriggerArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
};

export type Code = {
  __typename?: 'Code';
  /** Code line number */
  line?: Maybe<Scalars['String']['output']>;
  /** Code source */
  source?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated return type of CreateCsvExport. */
export type CreateCsvExportPayload = {
  __typename?: 'CreateCsvExportPayload';
  success: Scalars['Boolean']['output'];
};

/** Autogenerated return type of CreateCsvExportUrl. */
export type CreateCsvExportUrlPayload = {
  __typename?: 'CreateCsvExportUrlPayload';
  error?: Maybe<Scalars['String']['output']>;
  filename?: Maybe<Scalars['String']['output']>;
  success: Scalars['Boolean']['output'];
  url?: Maybe<Scalars['String']['output']>;
};

export type CreateStatusPageInput = {
  /** Description for the status page */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Hostname for the status page */
  hostname: Scalars['String']['input'];
  /** Minimum threshold for considering a service down */
  threshold?: InputMaybe<Scalars['Int']['input']>;
  /** Title of the status page */
  title: Scalars['String']['input'];
  /** Uptime monitors associated to the status page */
  uptimeMonitorIds?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** CSV Export */
export type CsvExport = {
  __typename?: 'CsvExport';
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  createdAt: Scalars['DateTime']['output'];
  errorMessage?: Maybe<Scalars['String']['output']>;
  /** Type of the export */
  exportType: Scalars['String']['output'];
  /** Filename */
  fileName?: Maybe<Scalars['String']['output']>;
  /** Size of the file */
  fileSize?: Maybe<Scalars['String']['output']>;
  /** Download url for the file */
  fileUrl?: Maybe<Scalars['String']['output']>;
  /** CSV Export ID */
  id: Scalars['String']['output'];
  /** Organization .for this export */
  organization?: Maybe<Organization>;
  /** User who requested the export. If empty, the user was deleted. */
  requestedBy?: Maybe<User>;
  /** Number of exported rows */
  rowCount?: Maybe<Scalars['Int']['output']>;
  /** Site for the export */
  site?: Maybe<App>;
  /** Status of the export */
  status: CsvExportStateEnum;
};

export enum CsvExportStateEnum {
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  Pending = 'PENDING',
  Processing = 'PROCESSING'
}

/** Marker with custom information */
export type CustomMarker = MarkerInterface & {
  __typename?: 'CustomMarker';
  /** UTC ISO8601 Datetime of deploy */
  createdAt: Scalars['DateTime']['output'];
  /** (Emoji) Icon for custom marker */
  icon: Scalars['String']['output'];
  /** Marker ID */
  id: Scalars['String']['output'];
  /** Message for custom marker */
  message: Scalars['String']['output'];
};

export type Dashboard = {
  __typename?: 'Dashboard';
  /** Timestamp at which the dashboard was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Dashboard description */
  description?: Maybe<Scalars['String']['output']>;
  /**
   * Deprecated list of graphs on the dashboard. Use `visuals` instead.
   * @deprecated Use the `Visual*` types instead. Graphs will be removed soon.
   */
  graphs: Array<DashboardGraph>;
  /** Dashboard ID */
  id: Scalars['String']['output'];
  /**
   * Dashboard key for AUTO generated dashboards, see `source` field. Used to identify what
   * "magic" dashboard it is.
   *
   */
  key?: Maybe<Scalars['String']['output']>;
  /** Dashboard source. User created or generated by the system. */
  source: DashboardSourceEnum;
  /** Dashboard title */
  title: Scalars['String']['output'];
  /** Timestamp at which the dashboard was last updated. */
  updatedAt: Scalars['DateTime']['output'];
  /**
   * Selected visual displayed on the dashboard. These are graphs and other components.
   *
   */
  visual?: Maybe<Visual>;
  /**
   * List of visuals displayed on the dashboard. These are graphs and other components.
   *
   */
  visuals: Array<Visual>;
};


export type DashboardVisualArgs = {
  id: Scalars['String']['input'];
};

export enum DashboardDisplayEnum {
  Area = 'AREA',
  AreaRelative = 'AREA_RELATIVE',
  Line = 'LINE'
}

export type DashboardGraph = {
  __typename?: 'DashboardGraph';
  /** Graph description */
  description?: Maybe<Scalars['String']['output']>;
  display?: Maybe<DashboardDisplayEnum>;
  drawNullAsZero?: Maybe<Scalars['Boolean']['output']>;
  format?: Maybe<Scalars['String']['output']>;
  formatInput?: Maybe<Scalars['String']['output']>;
  /**
   * Customizable name for the line.
   * Support replacements for the metric names, fields and tags with %name%,
   * %field% and %tag% (where tag is the tag name you've specified).
   *
   * Defaults to %name%
   *
   */
  lineLabel?: Maybe<Scalars['String']['output']>;
  metrics?: Maybe<Array<DashboardGraphMetric>>;
  minYAxis?: Maybe<Scalars['Float']['output']>;
  /** Graph title */
  title: Scalars['String']['output'];
};

export type DashboardGraphInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  display?: InputMaybe<DashboardDisplayEnum>;
  drawNullAsZero?: InputMaybe<Scalars['Boolean']['input']>;
  format?: InputMaybe<Scalars['String']['input']>;
  formatInput?: InputMaybe<Scalars['String']['input']>;
  /**
   * Customizable name for the line.
   * Support replacements for the metric names, fields and tags with %name%,
   * %field% and %tag% (where tag is the tag name you've specified).
   *
   * Defaults to %name%
   *
   */
  lineLabel?: InputMaybe<Scalars['String']['input']>;
  metrics?: InputMaybe<Array<DashboardGraphMetricInput>>;
  minYAxis?: InputMaybe<Scalars['Float']['input']>;
  /** List of tags for the graph */
  tags?: InputMaybe<Array<TagInput>>;
  title: Scalars['String']['input'];
};

export type DashboardGraphMetric = {
  __typename?: 'DashboardGraphMetric';
  /** Metric fields */
  fields?: Maybe<Array<MetricFieldEnum>>;
  /** Metric name */
  name: Scalars['String']['output'];
  /** List of tags of the graph */
  tags?: Maybe<Array<KeyStringValue>>;
};

export type DashboardGraphMetricInput = {
  fields: Array<MetricFieldEnum>;
  name: Scalars['String']['input'];
  /** List of tags for the metric */
  tags?: InputMaybe<Array<TagInput>>;
};

/**
 * Dashboard source. User created or automatically added by the system.
 * When AppSignal detects certain metrics, language or library specific metrics, it will add
 * a "magic" dashboard for it and related metrics.
 *
 */
export enum DashboardSourceEnum {
  /** Automatically created dashboards when certain app metrics are detected. */
  Auto = 'AUTO',
  /** Manually user created dashboards. */
  User = 'USER'
}

export type DataInput = {
  x: Scalars['DateTime']['input'];
  y?: InputMaybe<Scalars['Float']['input']>;
  y0?: InputMaybe<Scalars['Float']['input']>;
  y1?: InputMaybe<Scalars['Float']['input']>;
};

/** Marker with deploy information */
export type DeployMarker = MarkerInterface & {
  __typename?: 'DeployMarker';
  /** UTC ISO8601 Datetime of deploy */
  createdAt: Scalars['DateTime']['output'];
  /** Number of exceptions in deploy */
  exceptionCount: Scalars['Int']['output'];
  /** Exception rate in deploy */
  exceptionRate: Scalars['Float']['output'];
  /** Git(hub/lab) compare url */
  gitCompareUrl?: Maybe<Scalars['String']['output']>;
  /** Marker ID */
  id: Scalars['String']['output'];
  /** Time deploy was live in hours */
  liveFor: Scalars['Int']['output'];
  /** Time deploy was live in words */
  liveForInWords: Scalars['String']['output'];
  /** Namespace of the deploy */
  namespace?: Maybe<Scalars['String']['output']>;
  /** (Git) Revision */
  revision?: Maybe<Scalars['String']['output']>;
  /** First 8 characters of the git revision */
  shortRevision?: Maybe<Scalars['String']['output']>;
  /** User that performed the deploy */
  user?: Maybe<Scalars['String']['output']>;
};

export type Error = {
  __typename?: 'Error';
  /** Error class */
  class: Scalars['String']['output'];
  /** Error message */
  message?: Maybe<Scalars['String']['output']>;
};

/** Error cause for an exception sample */
export type ErrorCause = {
  __typename?: 'ErrorCause';
  firstLine?: Maybe<BacktraceLine>;
  /** Error message */
  message?: Maybe<Scalars['String']['output']>;
  /** Error name */
  name: Scalars['String']['output'];
};

export type Event = {
  __typename?: 'Event';
  /** Digest of event */
  digest?: Maybe<Scalars['String']['output']>;
  /** List of actions where this event occurred */
  incidents?: Maybe<Array<Maybe<PerformanceIncident>>>;
  /** Name of event */
  name?: Maybe<Scalars['String']['output']>;
  /** Payload of event */
  payload?: Maybe<Scalars['String']['output']>;
  /** Metrics timeseries data */
  timeseries?: Maybe<Timeseries>;
  /** Title of event */
  title?: Maybe<Scalars['String']['output']>;
};


export type EventTimeseriesArgs = {
  end?: InputMaybe<Scalars['DateTime']['input']>;
  start?: InputMaybe<Scalars['DateTime']['input']>;
  timeframe?: InputMaybe<TimeframeEnum>;
};

export type Exception = {
  __typename?: 'Exception';
  /** Backtrace of the exception */
  backtrace?: Maybe<Array<Maybe<BacktraceLine>>>;
  /** Message of the exception */
  message?: Maybe<Scalars['String']['output']>;
  /** Type/Name of the exception */
  name?: Maybe<Scalars['String']['output']>;
};

/** Exception incident in which a problem or exception was reported */
export type ExceptionIncident = IncidentInterface & TransactionIncidentInterface & {
  __typename?: 'ExceptionIncident';
  /** All action names where incident occurred, only exception incidents can have more than one action name */
  actionNames?: Maybe<Array<Scalars['String']['output']>>;
  /** App in which the incident occurred */
  app?: Maybe<App>;
  /** Users assigned to investigate or resolve this incident */
  assignees?: Maybe<Array<Maybe<User>>>;
  /** Total count of all recorded requests/jobs for this incident */
  count: Scalars['Int']['output'];
  /** Create time of incident */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** Incident description, or steps to solve the issue */
  description?: Maybe<Scalars['String']['output']>;
  /** All incident digests */
  digests?: Maybe<Array<Scalars['String']['output']>>;
  /** Error grouping strategy */
  errorGroupingStrategy: IncidentErrorGroupingEnum;
  /** Exception message */
  exceptionMessage?: Maybe<Scalars['String']['output']>;
  /** Name of exception, usually the error class */
  exceptionName?: Maybe<Scalars['String']['output']>;
  /** First (application) backtrace line */
  firstBacktraceLine?: Maybe<Scalars['String']['output']>;
  /** First deploy this error was seen in */
  firstMarker?: Maybe<DeployMarker>;
  /** Indicates wether this incidents has any samples in the retention of an account */
  hasSamplesInRetention: Scalars['Boolean']['output'];
  /** Incident ID */
  id: Scalars['String']['output'];
  /** List of available integration types */
  integrations?: Maybe<Array<Maybe<Integration>>>;
  /** Time incident last occurred at */
  lastOccurredAt?: Maybe<Scalars['DateTime']['output']>;
  /** Time of last recorded sample */
  lastSampleOccurredAt?: Maybe<Scalars['DateTime']['output']>;
  /** Logbook for incident */
  logbook: Logbook;
  /** Metadata distributions */
  metadataDistributions: Array<Maybe<MetadataDistributions>>;
  /** Namespace the incident occurred in. */
  namespace?: Maybe<Scalars['String']['output']>;
  /** Notification frequency for incident */
  notificationFrequency?: Maybe<IncidentNotificationFrequencyEnum>;
  /** Notification threshold (nth in hour/day) for incident */
  notificationThreshold?: Maybe<Scalars['Int']['output']>;
  /** Incident number */
  number: Scalars['Int']['output'];
  /** Total duration of all recorded requests/jobs for this incident and revision/marker */
  perMarkerCount?: Maybe<Scalars['Int']['output']>;
  /** Sample for incident, returns first sample that matches the arguments */
  sample?: Maybe<ExceptionSample>;
  /** Samples for incident */
  samples?: Maybe<Array<Maybe<ExceptionSample>>>;
  /** Severity of incident (critical/high/low/etc.) */
  severity?: Maybe<IncidentSeverityEnum>;
  /** Source of exception, can be 'sample' or 'span' */
  source?: Maybe<IncidentSourceEnum>;
  /** State of incident (open/closed) */
  state?: Maybe<IncidentStateEnum>;
  /** Incident summary */
  summary?: Maybe<Scalars['String']['output']>;
  /** Last update time of incident */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};


/** Exception incident in which a problem or exception was reported */
export type ExceptionIncidentPerMarkerCountArgs = {
  marker?: InputMaybe<Scalars['String']['input']>;
};


/** Exception incident in which a problem or exception was reported */
export type ExceptionIncidentSampleArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  timerange?: InputMaybe<Array<InputMaybe<Scalars['DateTime']['input']>>>;
  timestamp?: InputMaybe<Scalars['String']['input']>;
};


/** Exception incident in which a problem or exception was reported */
export type ExceptionIncidentSamplesArgs = {
  end?: InputMaybe<Scalars['DateTime']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  start?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Exception sample containing relevant sample data */
export type ExceptionSample = SampleInterface & {
  __typename?: 'ExceptionSample';
  /** The action name on which a sample was reported */
  action?: Maybe<Scalars['String']['output']>;
  /** App of sample */
  app: App;
  /** Internal app id of the sample */
  appId: Scalars['String']['output'];
  /** Root span attributes */
  attributes?: Maybe<Array<Maybe<KeyStringValue>>>;
  /** Breadcrumbs that lead up to the exception */
  breadcrumbs?: Maybe<Array<Maybe<Breadcrumb>>>;
  /** Time at which the sample was reported */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** Custom data */
  customData?: Maybe<Scalars['String']['output']>;
  duration?: Maybe<Scalars['Float']['output']>;
  /** Environment data */
  environment?: Maybe<Array<Maybe<KeyStringValue>>>;
  /** Errors that lead to the sample error */
  errorCauses?: Maybe<Array<Maybe<ErrorCause>>>;
  /** Exception that occurred on the sample */
  exception: Exception;
  /** First deploy this error was seen in */
  firstMarker?: Maybe<DeployMarker>;
  /** Internal id of the sample */
  id: Scalars['String']['output'];
  /** Incident of sample */
  incident?: Maybe<Incident>;
  /** Internal id of the incident this sample is linked to */
  incidentId: Scalars['String']['output'];
  /** Namespace the sample occurred in */
  namespace?: Maybe<Scalars['String']['output']>;
  /** Original ID of sample, if replaced by better sample */
  originalId?: Maybe<Scalars['String']['output']>;
  /** ID/timerange of original request, is present when sample differs from requested sample */
  originallyRequested?: Maybe<SampleOriginalRequestEnum>;
  /** Overview of sample, contains request id, hostname and tags */
  overview?: Maybe<Array<KeyStringValue>>;
  /** Sample params */
  params?: Maybe<Scalars['String']['output']>;
  /** Time spent in a queue before processing */
  queueDuration?: Maybe<Scalars['Int']['output']>;
  /** Revision of sample */
  revision?: Maybe<Scalars['String']['output']>;
  /** Session data */
  sessionData?: Maybe<Scalars['String']['output']>;
  /** Time when sample occurred */
  time?: Maybe<Scalars['DateTime']['output']>;
  /** Sample type version */
  version?: Maybe<Scalars['Int']['output']>;
};

/** A log export */
export type Export = {
  __typename?: 'Export';
  /** Export will be Gzipped when enabled */
  compressed: Scalars['Boolean']['output'];
  /** Export jobs for this export */
  exportJobs: Array<ExportJob>;
  /** Export ID */
  id: Scalars['String']['output'];
  lastRequestedAt?: Maybe<Scalars['DateTime']['output']>;
  /** Amount of export jobs that are in the `failed` state */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /** Type of the source */
  s3AccessKey: Scalars['String']['output'];
  /** Name of this source */
  s3Url: Scalars['String']['output'];
  /** Export will not run when state is Failed, and will run when state is Running or Retrying */
  state: ExportStateEnum;
};


/** A log export */
export type ExportExportJobsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

/** A log export job */
export type ExportJob = {
  __typename?: 'ExportJob';
  /** Export was compressed with Gzip */
  compressed: Scalars['Boolean']['output'];
  /** Duration of the export job in milliseconds */
  duration?: Maybe<Scalars['Float']['output']>;
  /** Type of the source */
  filename: Scalars['String']['output'];
  /** Export ID */
  id: Scalars['String']['output'];
  /** Amount of times this job has been retried */
  retryCount: Scalars['Int']['output'];
  state: ExportJobStateEnum;
  timestampFrom: Scalars['DateTime']['output'];
  timestampTo: Scalars['DateTime']['output'];
  /** Updates for this job */
  updates: Array<ExportJobUpdate>;
  /** Type of the source */
  url: Scalars['String']['output'];
};

export enum ExportJobStateEnum {
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  Requested = 'REQUESTED',
  Started = 'STARTED'
}

/** A log export job update */
export type ExportJobUpdate = {
  __typename?: 'ExportJobUpdate';
  /** Optional message from the update */
  message?: Maybe<Scalars['String']['output']>;
  /** Result (state) of the update */
  state: ExportJobStateEnum;
  /** Time the update happened */
  timestamp: Scalars['DateTime']['output'];
};

export enum ExportStateEnum {
  Failed = 'FAILED',
  Retrying = 'RETRYING',
  Running = 'RUNNING'
}

/**
 * A list of fields to return.
 *
 * Example:
 *
 * "fields": [
 *   {"field": COUNT},
 *   {"field": P90}
 * ]
 *
 */
export type Field = {
  /** Name of field to return (MEAN, COUNT, P90, P95 and GAUGE) */
  field: MetricFieldEnum;
};

export enum GettingStartedItemStateEnum {
  Completed = 'COMPLETED',
  Skipped = 'SKIPPED'
}

export type GitHub = IntegrationInterface & {
  __typename?: 'GitHub';
  /** Form data fields for GitHub integration */
  formData?: Maybe<GitHubFormData>;
  /** GitHub issues */
  issues?: Maybe<Array<Maybe<GitHubIssue>>>;
  /** Integration title */
  name: Scalars['String']['output'];
  /** Set to true if the integration needs a migration */
  needsMigration: Scalars['Boolean']['output'];
};

export type GitHubFormData = IntegrationFormDataInterface & {
  __typename?: 'GitHubFormData';
  /** Body */
  body: Scalars['String']['output'];
  /** Title */
  title: Scalars['String']['output'];
};

export type GitHubIssue = IntegrationResultInterface & {
  __typename?: 'GitHubIssue';
  /** Description provided by the AppSignal user */
  description: Scalars['String']['output'];
  /** Integration result ID */
  id: Scalars['String']['output'];
  /** Remote ID of integration (e.g. GitHub issue number or Asana ID */
  remoteId: Scalars['String']['output'];
  /** Title provided by the AppSignal user */
  title: Scalars['String']['output'];
  /** Url to remote integration */
  url: Scalars['String']['output'];
};

export type GitLab = IntegrationInterface & {
  __typename?: 'GitLab';
  /** Form data fields for GitLab integration */
  formData?: Maybe<GitLabFormData>;
  /** GitLab issues */
  issues?: Maybe<Array<Maybe<GitLabIssue>>>;
  /** Integration title */
  name: Scalars['String']['output'];
  /** Set to true if the integration needs a migration */
  needsMigration: Scalars['Boolean']['output'];
};

export type GitLabFormData = IntegrationFormDataInterface & {
  __typename?: 'GitLabFormData';
  /** Body */
  body: Scalars['String']['output'];
  /** Title */
  title: Scalars['String']['output'];
};

export type GitLabIssue = IntegrationResultInterface & {
  __typename?: 'GitLabIssue';
  /** Description provided by the AppSignal user */
  description: Scalars['String']['output'];
  /** Integration result ID */
  id: Scalars['String']['output'];
  /** Remote ID of integration (e.g. GitHub issue number or Asana ID */
  remoteId: Scalars['String']['output'];
  /** Title provided by the AppSignal user */
  title: Scalars['String']['output'];
  /** Url to remote integration */
  url: Scalars['String']['output'];
};

/** Incident objects. Can be performance, exception or log incident */
export type Incident = AnomalyIncident | ExceptionIncident | LogIncident | PerformanceIncident;

/** Error grouping of incident. */
export enum IncidentErrorGroupingEnum {
  /** Error grouping using the incident type (performance/error) and the namespace/action/error combination. */
  TypeAndAction = 'TYPE_AND_ACTION',
  /** Error grouping using the backtrace line. */
  TypeAndRelevantBacktraceLine = 'TYPE_AND_RELEVANT_BACKTRACE_LINE'
}

/** An AppSignal incident */
export type IncidentInterface = {
  /** App in which the incident occurred */
  app?: Maybe<App>;
  /** Users assigned to investigate or resolve this incident */
  assignees?: Maybe<Array<Maybe<User>>>;
  /** Total count of all recorded requests/jobs for this incident */
  count: Scalars['Int']['output'];
  /** Create time of incident */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** Incident description, or steps to solve the issue */
  description?: Maybe<Scalars['String']['output']>;
  /** All incident digests */
  digests?: Maybe<Array<Scalars['String']['output']>>;
  /** Incident ID */
  id: Scalars['String']['output'];
  /** List of available integration types */
  integrations?: Maybe<Array<Maybe<Integration>>>;
  /** Time incident last occurred at */
  lastOccurredAt?: Maybe<Scalars['DateTime']['output']>;
  /** Logbook for incident */
  logbook: Logbook;
  /** Notification frequency for incident */
  notificationFrequency?: Maybe<IncidentNotificationFrequencyEnum>;
  /** Incident number */
  number: Scalars['Int']['output'];
  /** Severity of incident (critical/high/low/etc.) */
  severity?: Maybe<IncidentSeverityEnum>;
  /** State of incident (open/closed) */
  state?: Maybe<IncidentStateEnum>;
  /** Incident summary */
  summary?: Maybe<Scalars['String']['output']>;
  /** Last update time of incident */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export enum IncidentNotificationFrequencyEnum {
  Always = 'ALWAYS',
  FirstAfterClose = 'FIRST_AFTER_CLOSE',
  FirstInDeploy = 'FIRST_IN_DEPLOY',
  Never = 'NEVER',
  NthInDay = 'NTH_IN_DAY',
  NthInHour = 'NTH_IN_HOUR'
}

export enum IncidentOrderEnum {
  Id = 'ID',
  Last = 'LAST'
}

export enum IncidentSeverityEnum {
  Critical = 'CRITICAL',
  High = 'HIGH',
  Informational = 'INFORMATIONAL',
  Low = 'LOW',
  None = 'NONE',
  Untriaged = 'UNTRIAGED'
}

/** The source of an incident (what generated this incident) */
export enum IncidentSourceEnum {
  /** This incident was generated by our sampling system */
  Sample = 'SAMPLE',
  /** This incident was extracted from an OpenTelemetry span */
  Span = 'SPAN'
}

export enum IncidentStateEnum {
  Closed = 'CLOSED',
  Open = 'OPEN',
  Wip = 'WIP'
}

/** Integration objects such as GitHub, GitLab, Trello etc. */
export type Integration = Asana | GitHub | GitLab | Jira | Linear | Phabricator | PivotalTracker | Shortcut | Trello;

export type IntegrationCreate = ItemInterface & {
  __typename?: 'IntegrationCreate';
  /** User that created the change. If empty, the user was deleted. */
  author?: Maybe<User>;
  /** Time at which the change was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Change ID. */
  id: Scalars['String']['output'];
  /** Integration name */
  name?: Maybe<Scalars['String']['output']>;
  /** Time at which the change was updated last. */
  updatedAt: Scalars['DateTime']['output'];
  /** Url to integration */
  url: Scalars['String']['output'];
};

/** Default form data fields */
export type IntegrationFormDataInterface = {
  /** Body */
  body: Scalars['String']['output'];
  /** Title */
  title: Scalars['String']['output'];
};

/** An AppSignal incident integration */
export type IntegrationInterface = {
  /** Integration title */
  name: Scalars['String']['output'];
  /** Set to true if the integration needs a migration */
  needsMigration: Scalars['Boolean']['output'];
};

/** An AppSignal incident integration result */
export type IntegrationResultInterface = {
  /** Description provided by the AppSignal user */
  description: Scalars['String']['output'];
  /** Integration result ID */
  id: Scalars['String']['output'];
  /** Remote ID of integration (e.g. GitHub issue number or Asana ID */
  remoteId: Scalars['String']['output'];
  /** Title provided by the AppSignal user */
  title: Scalars['String']['output'];
  /** Url to remote integration */
  url: Scalars['String']['output'];
};

/** A 'getting started' item */
export type Item = {
  __typename?: 'Item';
  /** User that created the change. If empty, the user was deleted. */
  author?: Maybe<User>;
  /** Time at which the item was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Item ID. */
  id: Scalars['String']['output'];
  /** Name of the getting started item */
  name: Scalars['String']['output'];
  /** State of the getting started item */
  state: GettingStartedItemStateEnum;
  /** Time at which the item was updated last. */
  updatedAt: Scalars['DateTime']['output'];
};

/** An AppSignal logbook item */
export type ItemInterface = {
  /** User that created the change. If empty, the user was deleted. */
  author?: Maybe<User>;
  /** Time at which the change was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Change ID. */
  id: Scalars['String']['output'];
  /** Time at which the change was updated last. */
  updatedAt: Scalars['DateTime']['output'];
};

export type Jira = IntegrationInterface & {
  __typename?: 'Jira';
  /** Form data fields for Jira integration */
  formData?: Maybe<JiraFormData>;
  /** Jira issues */
  issues?: Maybe<Array<Maybe<JiraIssue>>>;
  /** Integration title */
  name: Scalars['String']['output'];
  /** Set to true if the integration needs a migration */
  needsMigration: Scalars['Boolean']['output'];
};

export type JiraFormData = IntegrationFormDataInterface & {
  __typename?: 'JiraFormData';
  /** Body */
  body: Scalars['String']['output'];
  /** Title */
  title: Scalars['String']['output'];
};

export type JiraIssue = IntegrationResultInterface & {
  __typename?: 'JiraIssue';
  /** Description provided by the AppSignal user */
  description: Scalars['String']['output'];
  /** Integration result ID */
  id: Scalars['String']['output'];
  /** Remote ID of integration (e.g. GitHub issue number or Asana ID */
  remoteId: Scalars['String']['output'];
  /** Title provided by the AppSignal user */
  title: Scalars['String']['output'];
  /** Url to remote integration */
  url: Scalars['String']['output'];
};

/** Holds a key and a float value, used for metrics */
export type KeyFloatValue = {
  __typename?: 'KeyFloatValue';
  /** Key of keyvalue */
  key: Scalars['String']['output'];
  /** Float value of keyvalue */
  value?: Maybe<Scalars['Float']['output']>;
};

/** Holds a key and a value, used for metrics */
export type KeyStringValue = {
  __typename?: 'KeyStringValue';
  /** Key of key value */
  key: Scalars['String']['output'];
  /** Value of key value */
  value?: Maybe<Scalars['String']['output']>;
};

/** Key value hash GraphQL datastructure. Hash<String, String> */
export type KeyStringValueInput = {
  key?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export type Linear = IntegrationInterface & {
  __typename?: 'Linear';
  /** Form data fields for Linear integration */
  formData?: Maybe<LinearFormData>;
  /** Linear issues */
  issues?: Maybe<Array<Maybe<LinearIssue>>>;
  /** Integration title */
  name: Scalars['String']['output'];
  /** Set to true if the integration needs a migration */
  needsMigration: Scalars['Boolean']['output'];
};

export type LinearFormData = IntegrationFormDataInterface & {
  __typename?: 'LinearFormData';
  /** Body */
  body: Scalars['String']['output'];
  /** Title */
  title: Scalars['String']['output'];
};

export type LinearIssue = IntegrationResultInterface & {
  __typename?: 'LinearIssue';
  /** Description provided by the AppSignal user */
  description: Scalars['String']['output'];
  /** Integration result ID */
  id: Scalars['String']['output'];
  /** Remote ID of integration (e.g. GitHub issue number or Asana ID */
  remoteId: Scalars['String']['output'];
  /** Title provided by the AppSignal user */
  title: Scalars['String']['output'];
  /** Url to remote integration */
  url: Scalars['String']['output'];
};

export type Link = {
  __typename?: 'Link';
  sourceApp: App;
  targetApp: App;
};

/** Log incident in which a problem or exception was reported */
export type LogIncident = IncidentInterface & {
  __typename?: 'LogIncident';
  /** App in which the incident occurred */
  app?: Maybe<App>;
  /** Users assigned to investigate or resolve this incident */
  assignees?: Maybe<Array<Maybe<User>>>;
  /** Total count of all recorded requests/jobs for this incident */
  count: Scalars['Int']['output'];
  /** Create time of incident */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** Incident description, or steps to solve the issue */
  description?: Maybe<Scalars['String']['output']>;
  /** All incident digests */
  digests?: Maybe<Array<Scalars['String']['output']>>;
  /** Incident ID */
  id: Scalars['String']['output'];
  /** List of available integration types */
  integrations?: Maybe<Array<Maybe<Integration>>>;
  /** Time incident last occurred at */
  lastOccurredAt?: Maybe<Scalars['DateTime']['output']>;
  /** Last log line for incident */
  logLine?: Maybe<LogLine>;
  /** Logbook for incident */
  logbook: Logbook;
  /** Notification frequency for incident */
  notificationFrequency?: Maybe<IncidentNotificationFrequencyEnum>;
  /** Incident number */
  number: Scalars['Int']['output'];
  /** Severity of incident (critical/high/low/etc.) */
  severity?: Maybe<IncidentSeverityEnum>;
  /** State of incident (open/closed) */
  state?: Maybe<IncidentStateEnum>;
  /** Incident summary */
  summary?: Maybe<Scalars['String']['output']>;
  /** Trigger that triggered this incident */
  trigger: LogTrigger;
  /** Last update time of incident */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type LogLine = {
  __typename?: 'LogLine';
  /** Attributes for log line */
  attributes?: Maybe<Array<KeyStringValue>>;
  /** Log group */
  group?: Maybe<Scalars['String']['output']>;
  /** Hostname where log was recorded */
  hostname: Scalars['String']['output'];
  /** Log line UUID */
  id: Scalars['String']['output'];
  /** The log message */
  message: Scalars['String']['output'];
  /** Severity (warn/info etc.). */
  severity: SeverityEnum;
  /** Source of the log */
  source?: Maybe<Source>;
  /** Time of log occurrence */
  timestamp: Scalars['PreciseDateTime']['output'];
};

/** A log trigger. Uses query to match against log lines and creates an incident when found. */
export type LogTrigger = {
  __typename?: 'LogTrigger';
  /** Description provided by the user about the trigger */
  description?: Maybe<Scalars['String']['output']>;
  /** Alert configuration ID. */
  id: Scalars['String']['output'];
  /** Linked log view. */
  logView?: Maybe<View>;
  /** Trigger name. */
  name: Scalars['String']['output'];
  /** Incident notification option */
  notificationOptions?: Maybe<IncidentNotificationFrequencyEnum>;
  /** Incident notification duration treshold */
  notificationTriggerValue?: Maybe<Scalars['Int']['output']>;
  notifiers?: Maybe<Array<Notifier>>;
  previousTrigger?: Maybe<Trigger>;
  /** Query to perform against the log lines. */
  query?: Maybe<Scalars['String']['output']>;
  /** Severities */
  severities: Array<Maybe<Scalars['String']['output']>>;
  /** Log source ids */
  sourceIds: Array<Maybe<Scalars['String']['output']>>;
  /** Log sources */
  sources: Array<Maybe<Source>>;
  /** The user who created this Trigger. */
  user?: Maybe<User>;
};

export type Logbook = {
  __typename?: 'Logbook';
  /** Note ID. */
  id: Scalars['String']['output'];
  items: Array<LogbookItem>;
  /** ID of the pinned note. */
  pinnedNoteId?: Maybe<Scalars['String']['output']>;
};

/** Logbook item objects. */
export type LogbookItem = AssigneeChange | IntegrationCreate | ManualAlertStateChange | Note | NotificationFrequencyChange | NotificationThresholdChange | NotifierResult | SeverityChange | StateChange;

export enum LogbookableTypeEnum {
  Heartbeat = 'HEARTBEAT',
  Incident = 'INCIDENT'
}

export type Logs = {
  __typename?: 'Logs';
  /** Logs for this app */
  lines?: Maybe<Array<LogLine>>;
  /** Metrics for log metrics query */
  metrics?: Maybe<BulkTimeseries>;
  /** Query window in seconds */
  queryWindow: Scalars['Int']['output'];
  /** Log source */
  source?: Maybe<Source>;
  /** Log sources */
  sources: Array<Maybe<Source>>;
  /** Log sources */
  triggers: Array<Maybe<LogTrigger>>;
  vercelProjects: Array<Maybe<VercelProject>>;
};


export type LogsLinesArgs = {
  end?: InputMaybe<Scalars['PreciseDateTime']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<OrderEnum>;
  query?: InputMaybe<Scalars['String']['input']>;
  severities?: InputMaybe<Array<SeverityEnum>>;
  sourceIds?: InputMaybe<Array<Scalars['String']['input']>>;
  start?: InputMaybe<Scalars['PreciseDateTime']['input']>;
};


export type LogsMetricsArgs = {
  end?: InputMaybe<Scalars['PreciseDateTime']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  resolution?: InputMaybe<ResolutionEnum>;
  severities?: InputMaybe<Array<SeverityEnum>>;
  sourceIds?: InputMaybe<Array<Scalars['String']['input']>>;
  start?: InputMaybe<Scalars['PreciseDateTime']['input']>;
};


export type LogsSourceArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
};

export type ManualAlertStateChange = ItemInterface & {
  __typename?: 'ManualAlertStateChange';
  /** User that created the change. If empty, the user was deleted. */
  author?: Maybe<User>;
  /** Time at which the change was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Current state */
  currentState: AlertStateEnum;
  /** Change ID. */
  id: Scalars['String']['output'];
  /** Previous state */
  previousState?: Maybe<AlertStateEnum>;
  /** Time at which the change was updated last. */
  updatedAt: Scalars['DateTime']['output'];
};

/** An AppSignal marker */
export type MarkerInterface = {
  /** UTC ISO8601 Datetime of deploy */
  createdAt: Scalars['DateTime']['output'];
  /** Marker ID */
  id: Scalars['String']['output'];
};

/** Marker objects. Can be Deploy, Notification or Custom */
export type MarkerUnion = CustomMarker | DeployMarker | NotificationMarker;

export type MetadataDistributions = {
  __typename?: 'MetadataDistributions';
  /** Log line UUID */
  key: Scalars['String']['output'];
  /** Time of log occurrence */
  total: Scalars['Int']['output'];
  /** Time of log occurrence */
  unique: Scalars['Int']['output'];
};

/** Fields to return in metric query */
export enum MetricAggregateEnum {
  /** Returns average value of group */
  Avg = 'AVG',
  /** Returns the first seen value of field */
  First = 'FIRST',
  /** Returns the last seen value of field */
  Last = 'LAST',
  /** Returns maximum value of group */
  Max = 'MAX',
  /** Returns minimum value of group */
  Min = 'MIN',
  /** Sums values of group */
  Sum = 'SUM'
}

/**
 * Input to request a Metric List
 *
 * Example of an Aggegration input query:
 *
 * {
 *   "name": "transaction_duration",
 *   "tags": [
 *     {"key": "action",    "value": "*"},
 *     {"key": "namespace", "value": "b"}
 *   ],
 *   "fields": [{"field": COUNT, "aggregate": SUM}]
 * }
 *
 */
export type MetricAggregation = {
  /** List of fields and possible aggregation to return */
  fields: Array<AggregateField>;
  /** Name of the metric to query */
  name: Scalars['String']['input'];
  /** List of tags to narrow results */
  tags: Array<TagInput>;
};

/** Fields to return in metric query */
export enum MetricFieldEnum {
  /** Count of measurement/counter */
  Count = 'COUNT',
  /** Counter value */
  Counter = 'COUNTER',
  /** Gauge value */
  Gauge = 'GAUGE',
  /** Mean of measurement */
  Mean = 'MEAN',
  /** 90th percentile of measurement */
  P90 = 'P90',
  /** 95th percentile of measurement */
  P95 = 'P95'
}

/** Metric key exctracted from timeseries data. */
export type MetricKey = {
  __typename?: 'MetricKey';
  /** Digest of metric key. */
  digest: Scalars['String']['output'];
  /** Metric fields */
  fields: Array<MetricFieldEnum>;
  /** Metric key name. */
  name: Scalars['String']['output'];
  /** List of tags for metric key. */
  tags?: Maybe<Array<KeyStringValue>>;
  /** Metric type */
  type: MetricTypeEnum;
};

/**
 * Input to request timeseries Metric data
 *
 * Example of an Aggegration input query:
 *
 * {
 *   "name": "transaction_duration",
 *   "tags": [
 *     {"key": "action",    "value": "*"},
 *     {"key": "namespace", "value": "b"}
 *   ],
 *   "fields": [
 *     { "field": COUNT },
 *     { "field": MEAN }
 *   ]
 * }
 *
 */
export type MetricTimeseries = {
  /** List of fields and possible aggregation to return */
  fields: Array<Field>;
  /** Name of the metric to query */
  name: Scalars['String']['input'];
  /** List of tags to narrow results */
  tags?: InputMaybe<Array<TagInput>>;
};

/** Type of metric */
export enum MetricTypeEnum {
  Counter = 'COUNTER',
  Gauge = 'GAUGE',
  Measurement = 'MEASUREMENT'
}

/** Holds different metric fields */
export type Metrics = {
  __typename?: 'Metrics';
  /** List of metric keys */
  keys?: Maybe<Array<MetricKey>>;
  /** (Aggregated) List of requested metrics and fields */
  list?: Maybe<AggregationList>;
  /** Metrics timeseries data */
  timeseries?: Maybe<Timeseries>;
};


/** Holds different metric fields */
export type MetricsKeysArgs = {
  end?: InputMaybe<Scalars['DateTime']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  start?: InputMaybe<Scalars['DateTime']['input']>;
  tags?: InputMaybe<Array<TagInput>>;
  timeframe?: InputMaybe<TimeframeEnum>;
};


/** Holds different metric fields */
export type MetricsListArgs = {
  end?: InputMaybe<Scalars['DateTime']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  query: Array<InputMaybe<MetricAggregation>>;
  start?: InputMaybe<Scalars['DateTime']['input']>;
  timeframe?: InputMaybe<TimeframeEnum>;
};


/** Holds different metric fields */
export type MetricsTimeseriesArgs = {
  end?: InputMaybe<Scalars['DateTime']['input']>;
  query?: InputMaybe<Array<InputMaybe<MetricTimeseries>>>;
  start?: InputMaybe<Scalars['DateTime']['input']>;
  timeframe?: InputMaybe<TimeframeEnum>;
};

/** The mutation root of this schema. */
export type Mutation = {
  __typename?: 'Mutation';
  archiveAlert?: Maybe<Scalars['Boolean']['output']>;
  archiveTrigger?: Maybe<Trigger>;
  bulkUpdateIncidents?: Maybe<Array<Incident>>;
  createApp?: Maybe<App>;
  createAsanaTask?: Maybe<Incident>;
  createCheckInTrigger?: Maybe<CheckInTrigger>;
  createCheckInTriggerNote?: Maybe<CheckInTrigger>;
  createCsvExport?: Maybe<CreateCsvExportPayload>;
  createCsvExportUrl?: Maybe<CreateCsvExportUrlPayload>;
  createDashboard?: Maybe<Dashboard>;
  createGettingStartedItem?: Maybe<App>;
  createGithubIssue?: Maybe<Incident>;
  createGitlabIssue?: Maybe<Incident>;
  createIncidentNote?: Maybe<Incident>;
  createJiraIssue?: Maybe<Incident>;
  createLinearIssue?: Maybe<Incident>;
  createLogExport?: Maybe<Export>;
  createLogSource?: Maybe<Source>;
  createLogTrigger?: Maybe<LogTrigger>;
  createLogView?: Maybe<View>;
  createOrUpdateCustomMarker?: Maybe<CustomMarker>;
  createPhabricatorIssue?: Maybe<Incident>;
  createPivotalTrackerStory?: Maybe<Incident>;
  createSavedVisual?: Maybe<SavedVisual>;
  createShortcutStory?: Maybe<Incident>;
  createStatusPage?: Maybe<StatusPage>;
  createStatusPageUpdate?: Maybe<StatusPageUpdate>;
  createTrelloCard?: Maybe<Incident>;
  createTrigger?: Maybe<Trigger>;
  createUptimeMonitor?: Maybe<UptimeMonitor>;
  createVisualTimeseries?: Maybe<Dashboard>;
  deleteApp?: Maybe<App>;
  deleteCheckIn?: Maybe<CheckIn>;
  deleteCheckInTrigger?: Maybe<CheckInTrigger>;
  deleteCustomMarker?: Maybe<CustomMarker>;
  deleteDashboard?: Maybe<Dashboard>;
  deleteLogExport?: Maybe<Export>;
  deleteLogSource?: Maybe<Source>;
  deleteLogTrigger?: Maybe<LogTrigger>;
  deleteLogView?: Maybe<View>;
  deleteLogbookNote?: Maybe<Logbook>;
  deleteStatusPage?: Maybe<StatusPage>;
  deleteStatusPageUpdate?: Maybe<StatusPageUpdate>;
  deleteUptimeMonitor?: Maybe<UptimeMonitor>;
  deleteVisual?: Maybe<Dashboard>;
  endLastAlert?: Maybe<AnomalyIncident>;
  importDashboard?: Maybe<Dashboard>;
  markTooltipAsSeen?: Maybe<Viewer>;
  pinApp?: Maybe<App>;
  pinLogbookComment?: Maybe<Logbook>;
  removeIntegration?: Maybe<Incident>;
  reorderVisuals?: Maybe<Dashboard>;
  unpinApp?: Maybe<App>;
  unpinLogbookComment?: Maybe<Logbook>;
  updateCheckInTrigger?: Maybe<CheckInTrigger>;
  updateDashboard?: Maybe<Dashboard>;
  updateIncident?: Maybe<Incident>;
  updateLogExport?: Maybe<Export>;
  updateLogSource?: Maybe<Source>;
  updateLogTrigger?: Maybe<LogTrigger>;
  updateLogView?: Maybe<View>;
  updateStatusPage?: Maybe<StatusPage>;
  updateStatusPageUpdate?: Maybe<StatusPageUpdate>;
  updateUptimeMonitor?: Maybe<UptimeMonitor>;
  updateViewer?: Maybe<Viewer>;
  updateVisualTimeseries?: Maybe<Dashboard>;
  usedFeature?: Maybe<Viewer>;
};


/** The mutation root of this schema. */
export type MutationArchiveAlertArgs = {
  appId: Scalars['String']['input'];
  id: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationArchiveTriggerArgs = {
  appId: Scalars['String']['input'];
  id: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationBulkUpdateIncidentsArgs = {
  appId: Scalars['String']['input'];
  ids: Array<InputMaybe<Scalars['String']['input']>>;
  marker?: InputMaybe<Scalars['String']['input']>;
  severity?: InputMaybe<IncidentSeverityEnum>;
  state?: InputMaybe<IncidentStateEnum>;
};


/** The mutation root of this schema. */
export type MutationCreateAppArgs = {
  environment: Scalars['String']['input'];
  name: Scalars['String']['input'];
  organizationSlug: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationCreateAsanaTaskArgs = {
  appId: Scalars['String']['input'];
  description: Scalars['String']['input'];
  incidentNumber: Scalars['Int']['input'];
  title: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationCreateCheckInTriggerArgs = {
  appId: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  identifier: Scalars['String']['input'];
  kind: CheckInTriggerKindEnum;
  notifierIds?: InputMaybe<Array<Scalars['String']['input']>>;
  syntax?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  waitTimeMinutes: Scalars['Int']['input'];
};


/** The mutation root of this schema. */
export type MutationCreateCheckInTriggerNoteArgs = {
  appId: Scalars['String']['input'];
  checkInTriggerId: Scalars['String']['input'];
  content: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationCreateCsvExportArgs = {
  appId: Scalars['String']['input'];
  filters?: InputMaybe<Scalars['JSON']['input']>;
  type: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationCreateCsvExportUrlArgs = {
  exportId: Scalars['String']['input'];
  organizationSlug: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationCreateDashboardArgs = {
  appId: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  title: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationCreateGettingStartedItemArgs = {
  appId: Scalars['String']['input'];
  name: Scalars['String']['input'];
  state: GettingStartedItemStateEnum;
};


/** The mutation root of this schema. */
export type MutationCreateGithubIssueArgs = {
  appId: Scalars['String']['input'];
  description: Scalars['String']['input'];
  incidentNumber: Scalars['Int']['input'];
  title: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationCreateGitlabIssueArgs = {
  appId: Scalars['String']['input'];
  description: Scalars['String']['input'];
  incidentNumber: Scalars['Int']['input'];
  title: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationCreateIncidentNoteArgs = {
  appId: Scalars['String']['input'];
  content: Scalars['String']['input'];
  incidentNumber: Scalars['Int']['input'];
};


/** The mutation root of this schema. */
export type MutationCreateJiraIssueArgs = {
  appId: Scalars['String']['input'];
  description: Scalars['String']['input'];
  incidentNumber: Scalars['Int']['input'];
  title: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationCreateLinearIssueArgs = {
  appId: Scalars['String']['input'];
  description: Scalars['String']['input'];
  incidentNumber: Scalars['Int']['input'];
  title: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationCreateLogExportArgs = {
  appId: Scalars['String']['input'];
  compressed: Scalars['Boolean']['input'];
  s3AccessKey: Scalars['String']['input'];
  s3SecretKey: Scalars['String']['input'];
  s3Url: Scalars['String']['input'];
  sourceId: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationCreateLogSourceArgs = {
  appId: Scalars['String']['input'];
  fmt: SourceFormatEnum;
  integrationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  parseSeverity?: InputMaybe<Scalars['Boolean']['input']>;
  projectId?: InputMaybe<Scalars['String']['input']>;
  type: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationCreateLogTriggerArgs = {
  appId: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  notificationOptions?: InputMaybe<IncidentNotificationFrequencyEnum>;
  notificationTriggerValue?: InputMaybe<Scalars['Int']['input']>;
  notifierIds?: InputMaybe<Array<Scalars['String']['input']>>;
  query: Scalars['String']['input'];
  severities?: InputMaybe<Array<Scalars['String']['input']>>;
  sourceIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


/** The mutation root of this schema. */
export type MutationCreateLogViewArgs = {
  appId: Scalars['String']['input'];
  columns?: InputMaybe<Array<Scalars['String']['input']>>;
  lineHeight?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  query?: InputMaybe<Scalars['String']['input']>;
  severities?: InputMaybe<Array<Scalars['String']['input']>>;
  sourceIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


/** The mutation root of this schema. */
export type MutationCreateOrUpdateCustomMarkerArgs = {
  appId: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  icon: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
};


/** The mutation root of this schema. */
export type MutationCreatePhabricatorIssueArgs = {
  appId: Scalars['String']['input'];
  description: Scalars['String']['input'];
  incidentNumber: Scalars['Int']['input'];
  priority: Scalars['String']['input'];
  title: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationCreatePivotalTrackerStoryArgs = {
  appId: Scalars['String']['input'];
  description: Scalars['String']['input'];
  incidentNumber: Scalars['Int']['input'];
  title: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationCreateSavedVisualArgs = {
  appId: Scalars['String']['input'];
  resolution: Scalars['String']['input'];
  series: Array<InputMaybe<SerieInput>>;
  title: Scalars['String']['input'];
  valueFormat?: InputMaybe<Scalars['String']['input']>;
  valueInput?: InputMaybe<Scalars['String']['input']>;
};


/** The mutation root of this schema. */
export type MutationCreateShortcutStoryArgs = {
  appId: Scalars['String']['input'];
  description: Scalars['String']['input'];
  incidentNumber: Scalars['Int']['input'];
  title: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationCreateStatusPageArgs = {
  organizationSlug: Scalars['String']['input'];
  statusPage: CreateStatusPageInput;
};


/** The mutation root of this schema. */
export type MutationCreateStatusPageUpdateArgs = {
  organizationSlug: Scalars['String']['input'];
  statusPageId: Scalars['String']['input'];
  statusPageUpdate: StatusPageUpdateInput;
};


/** The mutation root of this schema. */
export type MutationCreateTrelloCardArgs = {
  appId: Scalars['String']['input'];
  description: Scalars['String']['input'];
  incidentNumber: Scalars['Int']['input'];
  listId: Scalars['String']['input'];
  title: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationCreateTriggerArgs = {
  appId: Scalars['String']['input'];
  condition: ThresholdConditionInput;
  cooldownDuration: Scalars['Int']['input'];
  dashboardId?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  field: MetricFieldEnum;
  format?: InputMaybe<Scalars['String']['input']>;
  formatInput?: InputMaybe<Scalars['String']['input']>;
  kind: Scalars['String']['input'];
  metricName: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  noMatchIsZero?: InputMaybe<Scalars['Boolean']['input']>;
  notifierIds?: InputMaybe<Array<Scalars['String']['input']>>;
  previousTriggerId?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Array<KeyStringValueInput>>;
  warmupDuration: Scalars['Int']['input'];
};


/** The mutation root of this schema. */
export type MutationCreateUptimeMonitorArgs = {
  appId: Scalars['String']['input'];
  uptimeMonitor: UptimeMonitorInput;
};


/** The mutation root of this schema. */
export type MutationCreateVisualTimeseriesArgs = {
  appId: Scalars['String']['input'];
  dashboardId: Scalars['String']['input'];
  visual: VisualTimeseriesInput;
};


/** The mutation root of this schema. */
export type MutationDeleteAppArgs = {
  appId: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationDeleteCheckInArgs = {
  appId: Scalars['String']['input'];
  id: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationDeleteCheckInTriggerArgs = {
  appId: Scalars['String']['input'];
  id: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationDeleteCustomMarkerArgs = {
  appId: Scalars['String']['input'];
  id: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationDeleteDashboardArgs = {
  appId: Scalars['String']['input'];
  id: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationDeleteLogExportArgs = {
  appId: Scalars['String']['input'];
  id: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationDeleteLogSourceArgs = {
  appId: Scalars['String']['input'];
  id: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationDeleteLogTriggerArgs = {
  appId: Scalars['String']['input'];
  id: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationDeleteLogViewArgs = {
  appId: Scalars['String']['input'];
  id: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationDeleteLogbookNoteArgs = {
  appId: Scalars['String']['input'];
  id: Scalars['String']['input'];
  logbookableId: Scalars['String']['input'];
  logbookableType: LogbookableTypeEnum;
};


/** The mutation root of this schema. */
export type MutationDeleteStatusPageArgs = {
  id: Scalars['String']['input'];
  organizationSlug: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationDeleteStatusPageUpdateArgs = {
  id: Scalars['String']['input'];
  organizationSlug: Scalars['String']['input'];
  statusPageId: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationDeleteUptimeMonitorArgs = {
  appId: Scalars['String']['input'];
  id: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationDeleteVisualArgs = {
  appId: Scalars['String']['input'];
  id: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationEndLastAlertArgs = {
  appId: Scalars['String']['input'];
  number: Scalars['Int']['input'];
};


/** The mutation root of this schema. */
export type MutationImportDashboardArgs = {
  appId: Scalars['String']['input'];
  json: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationMarkTooltipAsSeenArgs = {
  tooltip: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationPinAppArgs = {
  appId: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationPinLogbookCommentArgs = {
  appId: Scalars['String']['input'];
  commentId: Scalars['String']['input'];
  logbookableId: Scalars['String']['input'];
  logbookableType: LogbookableTypeEnum;
};


/** The mutation root of this schema. */
export type MutationRemoveIntegrationArgs = {
  appId: Scalars['String']['input'];
  id: Scalars['String']['input'];
  incidentNumber: Scalars['Int']['input'];
};


/** The mutation root of this schema. */
export type MutationReorderVisualsArgs = {
  appId: Scalars['String']['input'];
  id: Scalars['String']['input'];
  visualIds: Array<InputMaybe<Scalars['String']['input']>>;
};


/** The mutation root of this schema. */
export type MutationUnpinAppArgs = {
  appId: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationUnpinLogbookCommentArgs = {
  appId: Scalars['String']['input'];
  logbookableId: Scalars['String']['input'];
  logbookableType: LogbookableTypeEnum;
};


/** The mutation root of this schema. */
export type MutationUpdateCheckInTriggerArgs = {
  appId: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
  identifier?: InputMaybe<Scalars['String']['input']>;
  notifierIds?: InputMaybe<Array<Scalars['String']['input']>>;
  syntax?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  waitTimeMinutes?: InputMaybe<Scalars['Int']['input']>;
};


/** The mutation root of this schema. */
export type MutationUpdateDashboardArgs = {
  appId: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
  title: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationUpdateIncidentArgs = {
  appId: Scalars['String']['input'];
  assigneeIds?: InputMaybe<Array<Scalars['String']['input']>>;
  description?: InputMaybe<Scalars['String']['input']>;
  notificationFrequency?: InputMaybe<IncidentNotificationFrequencyEnum>;
  notificationThreshold?: InputMaybe<Scalars['Int']['input']>;
  number: Scalars['Int']['input'];
  severity?: InputMaybe<IncidentSeverityEnum>;
  state?: InputMaybe<IncidentStateEnum>;
};


/** The mutation root of this schema. */
export type MutationUpdateLogExportArgs = {
  appId: Scalars['String']['input'];
  compressed?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['String']['input'];
  s3AccessKey?: InputMaybe<Scalars['String']['input']>;
  s3SecretKey?: InputMaybe<Scalars['String']['input']>;
  s3Url?: InputMaybe<Scalars['String']['input']>;
};


/** The mutation root of this schema. */
export type MutationUpdateLogSourceArgs = {
  appId: Scalars['String']['input'];
  fmt: SourceFormatEnum;
  id: Scalars['String']['input'];
  name: Scalars['String']['input'];
  parseSeverity?: InputMaybe<Scalars['Boolean']['input']>;
};


/** The mutation root of this schema. */
export type MutationUpdateLogTriggerArgs = {
  appId: Scalars['String']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  notificationOptions?: InputMaybe<IncidentNotificationFrequencyEnum>;
  notificationTriggerValue?: InputMaybe<Scalars['Int']['input']>;
  notifierIds?: InputMaybe<Array<Scalars['String']['input']>>;
  query?: InputMaybe<Scalars['String']['input']>;
  severities?: InputMaybe<Array<Scalars['String']['input']>>;
  sourceIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


/** The mutation root of this schema. */
export type MutationUpdateLogViewArgs = {
  appId: Scalars['String']['input'];
  columns?: InputMaybe<Array<Scalars['String']['input']>>;
  id: Scalars['String']['input'];
  lineHeight?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  severities?: InputMaybe<Array<Scalars['String']['input']>>;
  sourceIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


/** The mutation root of this schema. */
export type MutationUpdateStatusPageArgs = {
  id: Scalars['String']['input'];
  organizationSlug: Scalars['String']['input'];
  statusPage: UpdateStatusPageInput;
};


/** The mutation root of this schema. */
export type MutationUpdateStatusPageUpdateArgs = {
  id: Scalars['String']['input'];
  organizationSlug: Scalars['String']['input'];
  statusPageId: Scalars['String']['input'];
  statusPageUpdate: StatusPageUpdateInput;
};


/** The mutation root of this schema. */
export type MutationUpdateUptimeMonitorArgs = {
  appId: Scalars['String']['input'];
  id: Scalars['String']['input'];
  uptimeMonitor: UptimeMonitorInput;
};


/** The mutation root of this schema. */
export type MutationUpdateViewerArgs = {
  chartColorPalette?: InputMaybe<Scalars['String']['input']>;
  chartLineThickness?: InputMaybe<Scalars['Float']['input']>;
  chartShowHorizontalLines?: InputMaybe<Scalars['Boolean']['input']>;
  chartShowMarkers?: InputMaybe<Scalars['Boolean']['input']>;
  chartShowVerticalLines?: InputMaybe<Scalars['Boolean']['input']>;
  hideGettingStarted?: InputMaybe<Scalars['Boolean']['input']>;
};


/** The mutation root of this schema. */
export type MutationUpdateVisualTimeseriesArgs = {
  appId: Scalars['String']['input'];
  visual: VisualTimeseriesInput;
  visualId: Scalars['String']['input'];
};


/** The mutation root of this schema. */
export type MutationUsedFeatureArgs = {
  feature: Scalars['String']['input'];
};

export type Note = {
  __typename?: 'Note';
  /** User that created the note. If empty, the user was deleted. */
  author?: Maybe<User>;
  /** Content of the note. */
  content: Scalars['String']['output'];
  /** Time at which the note was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Note ID. */
  id: Scalars['String']['output'];
  /** Time at which the note was updated last. */
  updatedAt: Scalars['DateTime']['output'];
  /** Returns true if user can delete this note. */
  viewerCanDelete: Scalars['Boolean']['output'];
};

export type NotificationFrequencyChange = ItemInterface & {
  __typename?: 'NotificationFrequencyChange';
  /** User that created the change. If empty, the user was deleted. */
  author?: Maybe<User>;
  /** Time at which the change was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Current frequency */
  currentFrequency: IncidentNotificationFrequencyEnum;
  /** Change ID. */
  id: Scalars['String']['output'];
  /** Previous frequency */
  previousFrequency?: Maybe<IncidentNotificationFrequencyEnum>;
  /** Time at which the change was updated last. */
  updatedAt: Scalars['DateTime']['output'];
};

/** Marker with important AppSignal information */
export type NotificationMarker = MarkerInterface & {
  __typename?: 'NotificationMarker';
  /** UTC ISO8601 Datetime of deploy */
  createdAt: Scalars['DateTime']['output'];
  /** Marker ID */
  id: Scalars['String']['output'];
  /** Message with AppSignal information */
  message: Scalars['String']['output'];
};

export type NotificationThresholdChange = ItemInterface & {
  __typename?: 'NotificationThresholdChange';
  /** User that created the change. If empty, the user was deleted. */
  author?: Maybe<User>;
  /** Time at which the change was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Current threshold */
  currentThreshold: Scalars['Int']['output'];
  /** Change ID. */
  id: Scalars['String']['output'];
  /** Previous threshold */
  previousThreshold?: Maybe<Scalars['Int']['output']>;
  /** Time at which the change was updated last. */
  updatedAt: Scalars['DateTime']['output'];
};

/** Destination for alerts, such as Slack, Discord or Email */
export type Notifier = {
  __typename?: 'Notifier';
  /** Notifier icon */
  icon: Scalars['String']['output'];
  /** Notifier ID */
  id: Scalars['String']['output'];
  /** User configured notifier name */
  name: Scalars['String']['output'];
};

export type NotifierResult = ItemInterface & {
  __typename?: 'NotifierResult';
  /** User that created the change. If empty, the user was deleted. */
  author?: Maybe<User>;
  /** Time at which the change was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Change ID. */
  id: Scalars['String']['output'];
  /** Notifier results */
  results: Array<Result>;
  /** Time at which the change was updated last. */
  updatedAt: Scalars['DateTime']['output'];
};

export enum OrderEnum {
  Asc = 'ASC',
  Desc = 'DESC'
}

/** An AppSignal organization */
export type Organization = {
  __typename?: 'Organization';
  /** Apps for this organization */
  apps?: Maybe<Array<Maybe<App>>>;
  /** List of CSV exports */
  csvExports?: Maybe<Array<Maybe<CsvExport>>>;
  /** Days left in trial, is `null` when plan is paid */
  daysLeftInTrial?: Maybe<Scalars['Int']['output']>;
  /** True if the organization is made by our Heroku add-on, */
  heroku: Scalars['Boolean']['output'];
  /** Organization ID */
  id: Scalars['String']['output'];
  /** Is true when account is in trial period */
  inTrial: Scalars['Boolean']['output'];
  /** Linked apps through distributed tracing */
  links?: Maybe<Array<Maybe<Link>>>;
  /** Organization name */
  name: Scalars['String']['output'];
  /** Organization Push API key */
  pushApiKey: Scalars['String']['output'];
  /** Filter samples across apps on 'overview' data */
  search?: Maybe<Array<Maybe<Sample>>>;
  /** Organization slug */
  slug: Scalars['String']['output'];
  /** Status page for given ID */
  statusPage?: Maybe<StatusPage>;
  /** Status page update for given ID */
  statusPageUpdate?: Maybe<StatusPageUpdate>;
  /** Status pages for organization */
  statusPages?: Maybe<Array<Maybe<StatusPage>>>;
  /** Throughput in last 30 days */
  throughputLast30Days: Scalars['Int']['output'];
  /** Organization retention in seconds */
  ttl: Scalars['Int']['output'];
  /** Users belonging to an oganization */
  users?: Maybe<Array<Maybe<User>>>;
};


/** An AppSignal organization */
export type OrganizationCsvExportsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** An AppSignal organization */
export type OrganizationLinksArgs = {
  end?: InputMaybe<Scalars['DateTime']['input']>;
  start?: InputMaybe<Scalars['DateTime']['input']>;
  timeframe?: InputMaybe<TimeframeEnum>;
};


/** An AppSignal organization */
export type OrganizationSearchArgs = {
  appId?: InputMaybe<Scalars['String']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  sampleType?: InputMaybe<SampleTypeEnum>;
  timerange?: InputMaybe<Array<InputMaybe<Scalars['DateTime']['input']>>>;
};


/** An AppSignal organization */
export type OrganizationStatusPageArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
};


/** An AppSignal organization */
export type OrganizationStatusPageUpdateArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  statusPageId?: InputMaybe<Scalars['String']['input']>;
};

/** Anomaly incidents with pagination information */
export type PaginatedAnomalyIncidents = {
  __typename?: 'PaginatedAnomalyIncidents';
  /** Anomaly incidents */
  rows: Array<AnomalyIncident>;
  /** Incident total */
  total?: Maybe<Scalars['Int']['output']>;
};

/** Exception incidents with pagination information */
export type PaginatedExceptionIncidents = {
  __typename?: 'PaginatedExceptionIncidents';
  /** Exception incidents */
  rows: Array<ExceptionIncident>;
  /** Incident total */
  total?: Maybe<Scalars['Int']['output']>;
};

/** Log incidents with pagination information */
export type PaginatedLogIncidents = {
  __typename?: 'PaginatedLogIncidents';
  /** Log incidents */
  rows: Array<LogIncident>;
  /** Incident total */
  total?: Maybe<Scalars['Int']['output']>;
};

/** Performance incidents with pagination information */
export type PaginatedPerformanceIncidents = {
  __typename?: 'PaginatedPerformanceIncidents';
  /** Performance incidents */
  rows: Array<PerformanceIncident>;
  /** Incident total */
  total?: Maybe<Scalars['Int']['output']>;
};

/** Performance incident in which a problem or exception was reported */
export type PerformanceIncident = IncidentInterface & TransactionIncidentInterface & {
  __typename?: 'PerformanceIncident';
  /** All action names where incident occurred, only exception incidents can have more than one action name */
  actionNames?: Maybe<Array<Scalars['String']['output']>>;
  /** App in which the incident occurred */
  app?: Maybe<App>;
  /** Users assigned to investigate or resolve this incident */
  assignees?: Maybe<Array<Maybe<User>>>;
  /** Total count of all recorded requests/jobs for this incident */
  count: Scalars['Int']['output'];
  /** Create time of incident */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** Deploy markers for incident */
  deployMarkers: Array<Maybe<PerformanceMarker>>;
  /** Incident description, or steps to solve the issue */
  description?: Maybe<Scalars['String']['output']>;
  /** All incident digests */
  digests?: Maybe<Array<Scalars['String']['output']>>;
  /** Value to indicate that any of the last 5 deploys had an N+1 query */
  hasNPlusOne?: Maybe<Scalars['Boolean']['output']>;
  /** Indicates wether this incidents has any samples in the retention of an account */
  hasSamplesInRetention: Scalars['Boolean']['output'];
  /** Incident ID */
  id: Scalars['String']['output'];
  /** List of available integration types */
  integrations?: Maybe<Array<Maybe<Integration>>>;
  /** Time incident last occurred at */
  lastOccurredAt?: Maybe<Scalars['DateTime']['output']>;
  /** Time of last recorded sample */
  lastSampleOccurredAt?: Maybe<Scalars['DateTime']['output']>;
  /** Logbook for incident */
  logbook: Logbook;
  /** Mean duration of all recorded requests/jobs for this incident */
  mean: Scalars['Float']['output'];
  /** Namespace the incident occurred in. */
  namespace?: Maybe<Scalars['String']['output']>;
  /** Notification frequency for incident */
  notificationFrequency?: Maybe<IncidentNotificationFrequencyEnum>;
  /** Notification threshold (in ms) for incident */
  notificationThreshold?: Maybe<Scalars['Int']['output']>;
  /** Incident number */
  number: Scalars['Int']['output'];
  /** Total duration of all recorded requests/jobs for this incident and revision/marker */
  perMarkerCount?: Maybe<Scalars['Int']['output']>;
  /** Value is true when we encountered a sample with a N+1 query for this incident and given revision/marker */
  perMarkerHasNPlusOne?: Maybe<Scalars['Boolean']['output']>;
  /** Mean duration of all recorded requests/jobs for this incident and given revision/marker */
  perMarkerMean?: Maybe<Scalars['Float']['output']>;
  /** Total duration of all recorded requests/jobs for this incident and given revision/marker */
  perMarkerTotalDuration?: Maybe<Scalars['Float']['output']>;
  /** Sample for incident, returns first sample that matches the arguments */
  sample?: Maybe<PerformanceSample>;
  /** Samples for incident */
  samples?: Maybe<Array<Maybe<PerformanceSample>>>;
  /** Severity of incident (critical/high/low/etc.) */
  severity?: Maybe<IncidentSeverityEnum>;
  /** State of incident (open/closed) */
  state?: Maybe<IncidentStateEnum>;
  /** Incident summary */
  summary?: Maybe<Scalars['String']['output']>;
  /** Total duration of all recorded requests/jobs for this incident */
  totalDuration: Scalars['Float']['output'];
  /** Last update time of incident */
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};


/** Performance incident in which a problem or exception was reported */
export type PerformanceIncidentPerMarkerCountArgs = {
  marker?: InputMaybe<Scalars['String']['input']>;
};


/** Performance incident in which a problem or exception was reported */
export type PerformanceIncidentPerMarkerHasNPlusOneArgs = {
  marker?: InputMaybe<Scalars['String']['input']>;
};


/** Performance incident in which a problem or exception was reported */
export type PerformanceIncidentPerMarkerMeanArgs = {
  marker?: InputMaybe<Scalars['String']['input']>;
};


/** Performance incident in which a problem or exception was reported */
export type PerformanceIncidentPerMarkerTotalDurationArgs = {
  marker?: InputMaybe<Scalars['String']['input']>;
};


/** Performance incident in which a problem or exception was reported */
export type PerformanceIncidentSampleArgs = {
  id?: InputMaybe<Scalars['String']['input']>;
  timerange?: InputMaybe<Array<InputMaybe<Scalars['DateTime']['input']>>>;
  timestamp?: InputMaybe<Scalars['String']['input']>;
};


/** Performance incident in which a problem or exception was reported */
export type PerformanceIncidentSamplesArgs = {
  end?: InputMaybe<Scalars['DateTime']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  start?: InputMaybe<Scalars['DateTime']['input']>;
};

/** An AppSignal incident */
export type PerformanceMarker = {
  __typename?: 'PerformanceMarker';
  /** Incident number */
  count: Scalars['Int']['output'];
  /** Id of deploy marker */
  id: Scalars['String']['output'];
  /** Deploy marker */
  marker: DeployMarker;
  /** Incident number */
  mean: Scalars['Int']['output'];
};

/** Performance sample containing relevant sample data */
export type PerformanceSample = SampleInterface & {
  __typename?: 'PerformanceSample';
  /** The action name on which a sample was reported */
  action?: Maybe<Scalars['String']['output']>;
  /** App of sample */
  app: App;
  /** Internal app id of the sample */
  appId: Scalars['String']['output'];
  /** Root span attributes */
  attributes?: Maybe<Array<Maybe<KeyStringValue>>>;
  /** Time at which the sample was reported */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** Custom data */
  customData?: Maybe<Scalars['String']['output']>;
  /** Duration of performance sample */
  duration: Scalars['Float']['output'];
  /** Environment data */
  environment?: Maybe<Array<Maybe<KeyStringValue>>>;
  /** Grouped allocations of performance sample */
  groupAllocations: Array<KeyFloatValue>;
  /** Grouped durations of performance sample */
  groupDurations: Array<KeyFloatValue>;
  /** Indicates if sample contains a N+1 query when true */
  hasNPlusOne: Scalars['Boolean']['output'];
  /** Internal id of the sample */
  id: Scalars['String']['output'];
  /** Incident of sample */
  incident?: Maybe<Incident>;
  /** Internal id of the incident this sample is linked to */
  incidentId: Scalars['String']['output'];
  /** Namespace the sample occurred in */
  namespace?: Maybe<Scalars['String']['output']>;
  /** Original ID of sample, if replaced by better sample */
  originalId?: Maybe<Scalars['String']['output']>;
  /** ID/timerange of original request, is present when sample differs from requested sample */
  originallyRequested?: Maybe<SampleOriginalRequestEnum>;
  /** Overview of sample, contains request id, hostname and tags */
  overview?: Maybe<Array<KeyStringValue>>;
  /** Sample params */
  params?: Maybe<Scalars['String']['output']>;
  /** Time spent in a queue before processing */
  queueDuration?: Maybe<Scalars['Int']['output']>;
  /** Revision of sample */
  revision?: Maybe<Scalars['String']['output']>;
  /** Session data */
  sessionData?: Maybe<Scalars['String']['output']>;
  /** Time when sample occurred */
  time?: Maybe<Scalars['DateTime']['output']>;
  /** Event timeline of performance sample */
  timeline: Array<Maybe<TimelineEvent>>;
  /** Amount of truncated events, if the event tree limit was reached */
  timelineTruncatedEvents: Scalars['Int']['output'];
  /** Sample type version */
  version?: Maybe<Scalars['Int']['output']>;
};

export type Phabricator = IntegrationInterface & {
  __typename?: 'Phabricator';
  /** Form data fields for Phabricator integration */
  formData?: Maybe<PhabricatorFormData>;
  /** Phabricator issues */
  issues?: Maybe<Array<Maybe<PhabricatorIssue>>>;
  /** Integration title */
  name: Scalars['String']['output'];
  /** Set to true if the integration needs a migration */
  needsMigration: Scalars['Boolean']['output'];
};

export type PhabricatorFormData = IntegrationFormDataInterface & {
  __typename?: 'PhabricatorFormData';
  /** Body */
  body: Scalars['String']['output'];
  /** Available priorities */
  priorities?: Maybe<Array<Maybe<KeyStringValue>>>;
  /** Title */
  title: Scalars['String']['output'];
};

export type PhabricatorIssue = IntegrationResultInterface & {
  __typename?: 'PhabricatorIssue';
  /** Description provided by the AppSignal user */
  description: Scalars['String']['output'];
  /** Integration result ID */
  id: Scalars['String']['output'];
  /** Priority of issue */
  priority: Scalars['String']['output'];
  /** Remote ID of integration (e.g. GitHub issue number or Asana ID */
  remoteId: Scalars['String']['output'];
  /** Title provided by the AppSignal user */
  title: Scalars['String']['output'];
  /** Url to remote integration */
  url: Scalars['String']['output'];
};

export type PivotalTracker = IntegrationInterface & {
  __typename?: 'PivotalTracker';
  /** Form data fields for PivotalTracker integration */
  formData?: Maybe<PivotalTrackerFormData>;
  /** Integration title */
  name: Scalars['String']['output'];
  /** Set to true if the integration needs a migration */
  needsMigration: Scalars['Boolean']['output'];
  /** PivotalTracker stories */
  stories?: Maybe<Array<Maybe<PivotalTrackerStory>>>;
};

export type PivotalTrackerFormData = IntegrationFormDataInterface & {
  __typename?: 'PivotalTrackerFormData';
  /** Body */
  body: Scalars['String']['output'];
  /** Title */
  title: Scalars['String']['output'];
};

export type PivotalTrackerStory = IntegrationResultInterface & {
  __typename?: 'PivotalTrackerStory';
  /** Description provided by the AppSignal user */
  description: Scalars['String']['output'];
  /** Integration result ID */
  id: Scalars['String']['output'];
  /** Remote ID of integration (e.g. GitHub issue number or Asana ID */
  remoteId: Scalars['String']['output'];
  /** Title provided by the AppSignal user */
  title: Scalars['String']['output'];
  /** Url to remote integration */
  url: Scalars['String']['output'];
};

/** Group of datapoints in timeseries */
export type Point = {
  __typename?: 'Point';
  /** Timestamp of bucket */
  timestamp: Scalars['Int']['output'];
  /** Points returned for bucket */
  values?: Maybe<Array<KeyFloatValue>>;
};

/** The query root of this schema */
export type Query = {
  __typename?: 'Query';
  /** AppSignal App */
  app?: Maybe<App>;
  organization?: Maybe<Organization>;
  /** List of supported timezones */
  timezones: Array<Timezone>;
  /** Current logged in user */
  viewer?: Maybe<Viewer>;
};


/** The query root of this schema */
export type QueryAppArgs = {
  id: Scalars['String']['input'];
};


/** The query root of this schema */
export type QueryOrganizationArgs = {
  slug: Scalars['String']['input'];
};

/** Resolution values to be used with metrics. */
export enum ResolutionEnum {
  /** Resolution of: daily */
  Daily = 'DAILY',
  /** Resolution of: hourly */
  Hourly = 'HOURLY',
  /** Resolution of: minutely */
  Minutely = 'MINUTELY'
}

export type Result = {
  __typename?: 'Result';
  /** Error count */
  errorCount: Scalars['Int']['output'];
  /** Timestamp of last notifier error */
  errorLast?: Maybe<Scalars['DateTime']['output']>;
  /** Notifier */
  notifier: Notifier;
  /** Success count */
  successCount: Scalars['Int']['output'];
  /** Timestamp of last succesfull notifier */
  successLast?: Maybe<Scalars['DateTime']['output']>;
};

/** Sample objects. Can be performance or exception sample */
export type Sample = ExceptionSample | PerformanceSample;

/** An AppSignal sample */
export type SampleInterface = {
  /** The action name on which a sample was reported */
  action?: Maybe<Scalars['String']['output']>;
  /** App of sample */
  app: App;
  /** Internal app id of the sample */
  appId: Scalars['String']['output'];
  /** Root span attributes */
  attributes?: Maybe<Array<Maybe<KeyStringValue>>>;
  /** Time at which the sample was reported */
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  /** Custom data */
  customData?: Maybe<Scalars['String']['output']>;
  duration?: Maybe<Scalars['Float']['output']>;
  /** Environment data */
  environment?: Maybe<Array<Maybe<KeyStringValue>>>;
  /** Internal id of the sample */
  id: Scalars['String']['output'];
  /** Incident of sample */
  incident?: Maybe<Incident>;
  /** Internal id of the incident this sample is linked to */
  incidentId: Scalars['String']['output'];
  /** Namespace the sample occurred in */
  namespace?: Maybe<Scalars['String']['output']>;
  /** Original ID of sample, if replaced by better sample */
  originalId?: Maybe<Scalars['String']['output']>;
  /** ID/timerange of original request, is present when sample differs from requested sample */
  originallyRequested?: Maybe<SampleOriginalRequestEnum>;
  /** Overview of sample, contains request id, hostname and tags */
  overview?: Maybe<Array<KeyStringValue>>;
  /** Sample params */
  params?: Maybe<Scalars['String']['output']>;
  /** Time spent in a queue before processing */
  queueDuration?: Maybe<Scalars['Int']['output']>;
  /** Revision of sample */
  revision?: Maybe<Scalars['String']['output']>;
  /** Session data */
  sessionData?: Maybe<Scalars['String']['output']>;
  /** Time when sample occurred */
  time?: Maybe<Scalars['DateTime']['output']>;
  /** Sample type version */
  version?: Maybe<Scalars['Int']['output']>;
};

/** The original requested item. We return this if we send an alternative */
export enum SampleOriginalRequestEnum {
  /** Sample was requested by ID, but we are returning an alternative */
  Id = 'ID',
  /** No alternative sample is being returned */
  None = 'NONE',
  /** Sample was requested by timerange, but we are returning an alternative */
  Timerange = 'TIMERANGE',
  /** Sample was requested by timestamp, but we are returning an alternative */
  Timestamp = 'TIMESTAMP'
}

/** Types of sample. */
export enum SampleTypeEnum {
  /** Exception sample */
  Exception = 'EXCEPTION',
  /** Performance sample */
  Performance = 'PERFORMANCE'
}

/** Saved visual */
export type SavedVisual = {
  __typename?: 'SavedVisual';
  /** URL to page with SVG of saved visual */
  csvUrl: Scalars['String']['output'];
  /** URL to page with SVG of saved visual */
  htmlUrl: Scalars['String']['output'];
  /** ID of saved visual */
  id: Scalars['String']['output'];
  /** URL to saved visual PNG */
  jsonUrl: Scalars['String']['output'];
  /** URL to saved visual PNG */
  pngUrl: Scalars['String']['output'];
  /** Title of the saved visual */
  title: Scalars['String']['output'];
};

export type SerieInput = {
  color: Scalars['String']['input'];
  data: Array<DataInput>;
  name: Scalars['String']['input'];
  renderer: Scalars['String']['input'];
};

export type Series = {
  __typename?: 'Series';
  /** Digest of metric key. */
  digest: Scalars['String']['output'];
  /** Metric name */
  name: Scalars['String']['output'];
  /** Metric tags */
  tags: Array<Maybe<KeyStringValue>>;
  /** Metric type */
  type: MetricTypeEnum;
};

export type SeverityChange = ItemInterface & {
  __typename?: 'SeverityChange';
  /** User that created the change. If empty, the user was deleted. */
  author?: Maybe<User>;
  /** Time at which the change was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Current severity */
  currentSeverity: IncidentSeverityEnum;
  /** Change ID. */
  id: Scalars['String']['output'];
  /** Previous severity */
  previousSeverity?: Maybe<IncidentSeverityEnum>;
  /** Time at which the change was updated last. */
  updatedAt: Scalars['DateTime']['output'];
};

export enum SeverityEnum {
  Alert = 'ALERT',
  Critical = 'CRITICAL',
  Debug = 'DEBUG',
  Error = 'ERROR',
  Fatal = 'FATAL',
  Info = 'INFO',
  Notice = 'NOTICE',
  Trace = 'TRACE',
  Unknown = 'UNKNOWN',
  Warn = 'WARN'
}

export type Shortcut = IntegrationInterface & {
  __typename?: 'Shortcut';
  /** Form data fields for Shortcut integration */
  formData?: Maybe<ShortcutFormData>;
  /** Integration title */
  name: Scalars['String']['output'];
  /** Set to true if the integration needs a migration */
  needsMigration: Scalars['Boolean']['output'];
  /** Shortcut stories */
  stories?: Maybe<Array<Maybe<ShortcutStory>>>;
};

export type ShortcutFormData = IntegrationFormDataInterface & {
  __typename?: 'ShortcutFormData';
  /** Body */
  body: Scalars['String']['output'];
  /** Title */
  title: Scalars['String']['output'];
};

export type ShortcutStory = IntegrationResultInterface & {
  __typename?: 'ShortcutStory';
  /** Description provided by the AppSignal user */
  description: Scalars['String']['output'];
  /** Integration result ID */
  id: Scalars['String']['output'];
  /** Remote ID of integration (e.g. GitHub issue number or Asana ID */
  remoteId: Scalars['String']['output'];
  /** Title provided by the AppSignal user */
  title: Scalars['String']['output'];
  /** Url to remote integration */
  url: Scalars['String']['output'];
};

/** A log source */
export type Source = {
  __typename?: 'Source';
  /** Indicates if source can be removed. The default Application source cannot be removed */
  canBeModified: Scalars['Boolean']['output'];
  /** Log exports for this source */
  export?: Maybe<Export>;
  /** Log format */
  fmt: SourceFormatEnum;
  /** Source ID */
  id: Scalars['String']['output'];
  /** API key of the source */
  key: Scalars['String']['output'];
  /** Metrics for log source */
  metrics?: Maybe<BulkTimeseries>;
  /** Name of this source */
  name: Scalars['String']['output'];
  /** If true, we'll attempt to parse any severity string from the log message */
  parseSeverity: Scalars['Boolean']['output'];
  /** Type of the source */
  type: Scalars['String']['output'];
  /** Usage in bytes for the last 24 hours */
  usageBytesLast24h: Scalars['Int']['output'];
};


/** A log source */
export type SourceMetricsArgs = {
  end?: InputMaybe<Scalars['PreciseDateTime']['input']>;
  resolution?: InputMaybe<ResolutionEnum>;
  start?: InputMaybe<Scalars['PreciseDateTime']['input']>;
};

export enum SourceFormatEnum {
  Json = 'JSON',
  Logfmt = 'LOGFMT',
  Plaintext = 'PLAINTEXT'
}

export type Spans = {
  __typename?: 'Spans';
  /** Metadata distribution */
  metadataDistribution: Array<Maybe<KeyFloatValue>>;
  /** Metadata distributions */
  metadataDistributions: Array<Maybe<MetadataDistributions>>;
};


export type SpansMetadataDistributionArgs = {
  incidentDigests: Array<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  metadataKey: Scalars['String']['input'];
};


export type SpansMetadataDistributionsArgs = {
  incidentDigests: Array<Scalars['String']['input']>;
};

export type StateChange = ItemInterface & {
  __typename?: 'StateChange';
  /** User that created the change. If empty, the user was deleted. */
  author?: Maybe<User>;
  /** Time at which the change was created. */
  createdAt: Scalars['DateTime']['output'];
  /** Current state */
  currentState: IncidentStateEnum;
  /** Change ID. */
  id: Scalars['String']['output'];
  /** Previous state */
  previousState?: Maybe<IncidentStateEnum>;
  /** Time at which the change was updated last. */
  updatedAt: Scalars['DateTime']['output'];
};

export type StatusPage = {
  __typename?: 'StatusPage';
  /** Description of the page */
  description?: Maybe<Scalars['String']['output']>;
  /** Boolean indicating if redirect from http to https has been enabled */
  forceSsl: Scalars['Boolean']['output'];
  /** Boolean indicating if SSL Cert has been requested for status page */
  hasSsl: Scalars['Boolean']['output'];
  /** Domain of the page */
  hostname: Scalars['String']['output'];
  /** ID of the status page */
  id: Scalars['String']['output'];
  /** State of all monitored services on the status page. */
  state: StatusPageStateEnum;
  /** Minimum threshold for considering a service down */
  threshold?: Maybe<Scalars['Int']['output']>;
  /** Title of the page */
  title: Scalars['String']['output'];
  /** Updates from the last 7 days for this page */
  updates?: Maybe<Array<StatusPageUpdate>>;
  /** Ids for uptime monitors */
  uptimeMonitorIds?: Maybe<Array<Scalars['String']['output']>>;
  /** Uptime monitors associated with this page */
  uptimeMonitors?: Maybe<Array<UptimeMonitor>>;
};

/** Status page state */
export enum StatusPageStateEnum {
  /** down */
  Down = 'DOWN',
  /** up */
  Up = 'UP'
}

export type StatusPageUpdate = {
  __typename?: 'StatusPageUpdate';
  /** Time of status update */
  createdAt: Scalars['DateTime']['output'];
  /** Description of the update */
  description: Scalars['String']['output'];
  /** ID of the status page update */
  id: Scalars['String']['output'];
  /** State of the update. */
  state: StatusPageUpdateStateEnum;
  /** Title of the update */
  title: Scalars['String']['output'];
};

export type StatusPageUpdateInput = {
  /** Description for the status page */
  description?: InputMaybe<Scalars['String']['input']>;
  /** State for the update */
  state: StatusPageUpdateStateEnum;
  /** Title of the status page */
  title: Scalars['String']['input'];
};

/** Status page update state */
export enum StatusPageUpdateStateEnum {
  /** identified */
  Identified = 'IDENTIFIED',
  /** investigating */
  Investigating = 'INVESTIGATING',
  /** recovering */
  Recovering = 'RECOVERING',
  /** resolved */
  Resolved = 'RESOLVED'
}

/**
 * A list of tags to narrow/group aggregation, example:
 *
 * "tags": [
 *   {"key": "action",    "value": "*"},
 *   {"key": "namespace", "value": "b"}
 * ]
 *
 */
export type TagInput = {
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

/** Comparision operation to use to compare against a value. */
export enum ThresholdAlertSettingComparisonOperationEnum {
  /** Equal */
  Equal = 'EQUAL',
  /** Greater than */
  GreaterThan = 'GREATER_THAN',
  /** Greater than or equal */
  GreaterThanOrEqual = 'GREATER_THAN_OR_EQUAL',
  /** Less than */
  LessThan = 'LESS_THAN',
  /** Less than or equal */
  LessThanOrEqual = 'LESS_THAN_OR_EQUAL',
  /** Not equal */
  NotEqual = 'NOT_EQUAL'
}

/** Settings for the AlertConfiguration to compare against. */
export type ThresholdCondition = {
  __typename?: 'ThresholdCondition';
  /** Comparision operator to use in this alert check. */
  comparisonOperator: ThresholdAlertSettingComparisonOperationEnum;
  /** Human readable version of the comparision used in this check. */
  humanComparisonOperator: Scalars['String']['output'];
  /** Threshold alert setting ID. */
  id: Scalars['String']['output'];
  /** Threshold value. The comparison operator uses this value to compare against the real value. */
  value: Scalars['Float']['output'];
};

/** Settings for the AlertConfiguration to compare against. */
export type ThresholdConditionInput = {
  /** Comparision to use in this check. */
  comparisonOperator: ThresholdAlertSettingComparisonOperationEnum;
  /** Threshold value. The comparison operator uses this value to compare against the real value. */
  value?: InputMaybe<Scalars['Float']['input']>;
};

export type TimeDetectiveDataPoint = {
  __typename?: 'TimeDetectiveDataPoint';
  /** Action of snapshot */
  actionName?: Maybe<Scalars['String']['output']>;
  /** Exception of snapshot */
  exceptionName?: Maybe<Scalars['String']['output']>;
  /** Incident of snapshot */
  incident?: Maybe<Incident>;
  /** Average duration of the samples in this incident for the selected timeframe. */
  mean?: Maybe<Scalars['Float']['output']>;
  /** Namespace of snapshot */
  namespace?: Maybe<Scalars['String']['output']>;
  /** 90th percentile of the samples in this incident for the selected timeframe. */
  p90?: Maybe<Scalars['Float']['output']>;
  /** Throughput of the samples in this incident for the selected timeframe. */
  throughput?: Maybe<Scalars['Int']['output']>;
};

/** Timeframes to be used with metrics. */
export enum TimeframeEnum {
  /** Timeframe of: 1 */
  R1H = 'R1H',
  /** Timeframe of: 4 */
  R4H = 'R4H',
  /** Timeframe of: 7 */
  R7D = 'R7D',
  /** Timeframe of: 8 */
  R8H = 'R8H',
  /** Timeframe of: 12 */
  R12H = 'R12H',
  /** Timeframe of: 24 */
  R24H = 'R24H',
  /** Timeframe of: 30 */
  R30D = 'R30D',
  /** Timeframe of: 48 */
  R48H = 'R48H'
}

/** Event belonging in a performance sample timeline */
export type TimelineEvent = {
  __typename?: 'TimelineEvent';
  /** Event action (e.g. query) */
  action: Scalars['String']['output'];
  /** Memory allocations during event */
  allocationCount?: Maybe<Scalars['Float']['output']>;
  /** Memory allocations of all children */
  childAllocationCount?: Maybe<Scalars['Float']['output']>;
  /** Duration of all children of eveni, in ms */
  childDuration: Scalars['Float']['output'];
  /** Numer of times event has occured. More than one time means N+1 */
  count: Scalars['Int']['output'];
  /** Event digest, idempotent for action/payload combination */
  digest: Scalars['String']['output'];
  /** Duration of event, in ms */
  duration: Scalars['Float']['output'];
  /** Time event record was ended */
  end: Scalars['Float']['output'];
  /** Event group (e.g. sql) */
  group?: Maybe<Scalars['String']['output']>;
  /** Nesting level of event */
  level: Scalars['Int']['output'];
  /** Event name (e.g. User load) */
  name?: Maybe<Scalars['String']['output']>;
  /** Event payload (e.g. a sanitized SQL query) */
  payload?: Maybe<TimelineEventPayload>;
  /** Time event record was started */
  time: Scalars['Float']['output'];
  /** True if this is a wrapping event */
  wrapping: Scalars['Boolean']['output'];
};

/** Payload belonging event in a performance sample timeline */
export type TimelineEventPayload = {
  __typename?: 'TimelineEventPayload';
  /** Body of payload (e.g an `sql query) */
  body?: Maybe<Scalars['String']['output']>;
  /** Name of payload (e.g. User Load) */
  name?: Maybe<Scalars['String']['output']>;
};

/** Timeseries data of metrics */
export type Timeseries = {
  __typename?: 'Timeseries';
  /** End time of performed metric query */
  end: Scalars['DateTime']['output'];
  /** Keys used to fetch metrics */
  keys?: Maybe<Array<MetricKey>>;
  /** Rows returned for aggregated list */
  points?: Maybe<Array<Point>>;
  /** Resolution fo returned series */
  resolution?: Maybe<ResolutionEnum>;
  /** Start time of performed metric query */
  start: Scalars['DateTime']['output'];
};

/** Timezone information */
export type Timezone = {
  __typename?: 'Timezone';
  /** Timezone abbreviation */
  identifier: Scalars['String']['output'];
  /** Timezone friendly name */
  name: Scalars['String']['output'];
  /** Timezone UTC offset */
  offset: Scalars['String']['output'];
};

/** An AppSignal transaction incident */
export type TransactionIncidentInterface = {
  /** All action names where incident occurred, only exception incidents can have more than one action name */
  actionNames?: Maybe<Array<Scalars['String']['output']>>;
  /** Indicates wether this incidents has any samples in the retention of an account */
  hasSamplesInRetention: Scalars['Boolean']['output'];
  /** Time of last recorded sample */
  lastSampleOccurredAt?: Maybe<Scalars['DateTime']['output']>;
  /** Namespace the incident occurred in. */
  namespace?: Maybe<Scalars['String']['output']>;
  /** Total duration of all recorded requests/jobs for this incident and revision/marker */
  perMarkerCount?: Maybe<Scalars['Int']['output']>;
};


/** An AppSignal transaction incident */
export type TransactionIncidentInterfacePerMarkerCountArgs = {
  marker?: InputMaybe<Scalars['String']['input']>;
};

export type Trello = IntegrationInterface & {
  __typename?: 'Trello';
  /** Trello cards */
  cards?: Maybe<Array<Maybe<TrelloCard>>>;
  /** Form data fields for Trello integration */
  formData?: Maybe<TrelloFormData>;
  /** Integration title */
  name: Scalars['String']['output'];
  /** Set to true if the integration needs a migration */
  needsMigration: Scalars['Boolean']['output'];
};

export type TrelloCard = IntegrationResultInterface & {
  __typename?: 'TrelloCard';
  /** Description provided by the AppSignal user */
  description: Scalars['String']['output'];
  /** Integration result ID */
  id: Scalars['String']['output'];
  /** ID of the destination list */
  listId: Scalars['String']['output'];
  /** Remote ID of integration (e.g. GitHub issue number or Asana ID */
  remoteId: Scalars['String']['output'];
  /** Title provided by the AppSignal user */
  title: Scalars['String']['output'];
  /** Url to remote integration */
  url: Scalars['String']['output'];
};

export type TrelloFormData = IntegrationFormDataInterface & {
  __typename?: 'TrelloFormData';
  /** Body */
  body: Scalars['String']['output'];
  /** Available Trello lists */
  lists: Array<KeyStringValue>;
  /** Title */
  title: Scalars['String']['output'];
};

/** An alert trigger. Configuration used to decide if a metric value requires an alert. */
export type Trigger = {
  __typename?: 'Trigger';
  /**
   * Time in minutes AppSignal waits before closing an alert and sending a notification about it.
   *
   */
  cooldownDuration: Scalars['Int']['output'];
  /** ID of linked dashboard to trigger. */
  dashboardId?: Maybe<Scalars['String']['output']>;
  /** Description provided by the user about the trigger */
  description?: Maybe<Scalars['String']['output']>;
  /** Field which will be compared against for this alert. */
  field: MetricFieldEnum;
  /**
   * The data format of the metric the trigger is configured.
   *
   * For more information, see our docs:
   * https://docs.appsignal.com/metrics/custom.html#metric-values
   *
   */
  format?: Maybe<Scalars['String']['output']>;
  /**
   * The data format input size for the "size" format.
   *
   * For more information, see our docs:
   * https://docs.appsignal.com/metrics/custom.html#metric-values
   *
   */
  formatInput?: Maybe<Scalars['String']['output']>;
  /** Alert configuration ID. */
  id: Scalars['String']['output'];
  /** Trigger kind (exception rate/ throughput etc). */
  kind: Scalars['String']['output'];
  /** The metric this trigger is about. */
  metricName: Scalars['String']['output'];
  /** Name provided by the user about the trigger */
  name: Scalars['String']['output'];
  /** If true, when no data is received it treats the value as 0. */
  noMatchIsZero: Scalars['Boolean']['output'];
  notifiers?: Maybe<Array<Notifier>>;
  previousTrigger?: Maybe<Trigger>;
  /**
   * Map of tags that will filter which metrics to include. Values may include wildcards: *value*
   *
   */
  tags?: Maybe<Array<KeyStringValue>>;
  thresholdCondition: ThresholdCondition;
  /** The user who created this Trigger. */
  user?: Maybe<User>;
  /**
   * Time in minutes AppSignal waits before opening an alert and sending a notification about it.
   *
   */
  warmupDuration: Scalars['Int']['output'];
};

export type UpdateStatusPageInput = {
  /** Description for the status page */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Minimum threshold for considering a service down */
  threshold?: InputMaybe<Scalars['Int']['input']>;
  /** Title of the status page */
  title: Scalars['String']['input'];
  /** Uptime monitors associated to the status page */
  uptimeMonitorIds?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type UptimeMonitor = {
  __typename?: 'UptimeMonitor';
  /** List of alerts for this montior */
  alerts: Array<Maybe<Alert>>;
  /** {:description=>"If present, uptime monitor will check response body content for this string.", :null=>true} */
  checkBodyContent?: Maybe<Scalars['String']['output']>;
  /** Description for monitor */
  description?: Maybe<Scalars['String']['output']>;
  /** Headers to send with monitor request */
  headers?: Maybe<Array<Maybe<KeyStringValue>>>;
  /** Uptime Monitor ID. */
  id: Scalars['String']['output'];
  /** Name of endpoint. */
  name: Scalars['String']['output'];
  /** Notifier ids for moniotor */
  notifierIds: Array<Maybe<Scalars['String']['output']>>;
  /** List of notifiers for this monitor */
  notifiers: Array<Maybe<Notifier>>;
  /** {:description=>"List of regions where the monitor is pinging from", :null=>false} */
  regions?: Maybe<Array<UptimeMonitorRegionEnum>>;
  /** List of status pages this monitor is used on */
  statusPages: Array<Maybe<StatusPage>>;
  /** Url for endpoint. */
  url: Scalars['String']['output'];
  /** Warmup duration in minutes */
  warmupDuration: Scalars['Int']['output'];
};

export type UptimeMonitorInput = {
  /** Body content to check for */
  checkBodyContent?: InputMaybe<Scalars['String']['input']>;
  /** Description of monitor, shown in app */
  description?: InputMaybe<Scalars['String']['input']>;
  /** List of headers to send with the request */
  headers?: InputMaybe<Array<KeyStringValueInput>>;
  /** Name of monitor, shown on public page */
  name: Scalars['String']['input'];
  /** IDs of notifiers to use when URL doesn't respond */
  notifierIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Regions to check from */
  regions: Array<InputMaybe<UptimeMonitorRegionEnum>>;
  /** URL to monitor */
  url: Scalars['String']['input'];
  /** Time an URL must be down before we alert */
  warmupDuration?: InputMaybe<Scalars['Int']['input']>;
};

export type UptimeMonitorRegion = {
  __typename?: 'UptimeMonitorRegion';
  /** Uptime Monitor Region id. */
  id: UptimeMonitorRegionEnum;
  /** Name of region. */
  name: Scalars['String']['output'];
};

/** Available regions for Uptime monitoring. */
export enum UptimeMonitorRegionEnum {
  /** Uptime monitor region: asia-pacific */
  AsiaPacific = 'ASIA_PACIFIC',
  /** Uptime monitor region: europe */
  Europe = 'EUROPE',
  /** Uptime monitor region: north-america */
  NorthAmerica = 'NORTH_AMERICA',
  /** Uptime monitor region: south-america */
  SouthAmerica = 'SOUTH_AMERICA'
}

/** An AppSignal user */
export type User = UserInterface & {
  __typename?: 'User';
  /** User primary Email */
  email: Scalars['String']['output'];
  /** User email hash as SHA256 */
  emailHash: Scalars['String']['output'];
  /** User has gravatar enabled */
  gravatarEnabled: Scalars['Boolean']['output'];
  /** User wants to hide getting started screen */
  hideGettingStarted: Scalars['Boolean']['output'];
  /** User ID */
  id: Scalars['String']['output'];
  /** User initials */
  initials: Scalars['String']['output'];
  /** User's name */
  name: Scalars['String']['output'];
  /** All organizations this user has access to */
  organizations: Array<Maybe<Organization>>;
};

/** Common user fields */
export type UserInterface = {
  /** User primary Email */
  email: Scalars['String']['output'];
  /** User email hash as SHA256 */
  emailHash: Scalars['String']['output'];
  /** User has gravatar enabled */
  gravatarEnabled: Scalars['Boolean']['output'];
  /** User wants to hide getting started screen */
  hideGettingStarted: Scalars['Boolean']['output'];
  /** User ID */
  id: Scalars['String']['output'];
  /** User initials */
  initials: Scalars['String']['output'];
  /** User's name */
  name: Scalars['String']['output'];
  /** All organizations this user has access to */
  organizations: Array<Maybe<Organization>>;
};

export type Values = {
  __typename?: 'Values';
  /** Time of log occurrence */
  values: Array<KeyFloatValue>;
};

/** A Vercel project, used in Log Source */
export type VercelProject = {
  __typename?: 'VercelProject';
  /** Vercel Integration ID */
  integrationId: Scalars['String']['output'];
  /** Name of project */
  name: Scalars['String']['output'];
  /** Vercel Project ID */
  projectId: Scalars['String']['output'];
};

/** A log view */
export type View = {
  __typename?: 'View';
  /** Columns of this view */
  columns?: Maybe<Array<Scalars['String']['output']>>;
  /** View ID */
  id: Scalars['String']['output'];
  /** Line height of this view */
  lineHeight: Scalars['String']['output'];
  /** Name of this view */
  name: Scalars['String']['output'];
  /** Query of this view */
  query: Scalars['String']['output'];
  /** Severities of this view */
  severities: Array<Scalars['String']['output']>;
  /** Sources of this view */
  sourceIds: Array<Scalars['String']['output']>;
};

/** A logged-in AppSignal user */
export type Viewer = UserInterface & {
  __typename?: 'Viewer';
  /** List of all incidents assigned to viewer */
  assignedIncidents: Array<Maybe<Incident>>;
  /** Chart color palette */
  chartColorPalette: Scalars['String']['output'];
  /** Chart line thickness */
  chartLineThickness: Scalars['Float']['output'];
  /** Show horizontal chart lines when true */
  chartShowHorizontalLines: Scalars['Boolean']['output'];
  /** Show chart markers when true */
  chartShowMarkers?: Maybe<Scalars['Boolean']['output']>;
  /** Show vertical chart lines when true */
  chartShowVerticalLines: Scalars['Boolean']['output'];
  /** User primary Email */
  email: Scalars['String']['output'];
  /** User email hash as SHA256 */
  emailHash: Scalars['String']['output'];
  /** User has gravatar enabled */
  gravatarEnabled: Scalars['Boolean']['output'];
  /** User wants to hide getting started screen */
  hideGettingStarted: Scalars['Boolean']['output'];
  /** User ID */
  id: Scalars['String']['output'];
  /** List of all incidents within the projects the user has access to */
  incidents: Array<Maybe<Incident>>;
  /** User initials */
  initials: Scalars['String']['output'];
  /** Is user controlled by SAML Single Sign-On */
  isExternallyControlled: Scalars['Boolean']['output'];
  /** User's name */
  name: Scalars['String']['output'];
  /** List of organizations user belongs to */
  organizations: Array<Maybe<Organization>>;
  /** List of tooltips seen by the user */
  seenTooltips: Array<Scalars['String']['output']>;
  /** Authentication token */
  token: Scalars['String']['output'];
  /** List of features used by user */
  usedFeatures: Array<Scalars['String']['output']>;
};


/** A logged-in AppSignal user */
export type ViewerAssignedIncidentsArgs = {
  appId?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<IncidentOrderEnum>;
  query?: InputMaybe<Scalars['String']['input']>;
  severity?: InputMaybe<IncidentSeverityEnum>;
  state?: InputMaybe<Array<IncidentStateEnum>>;
};


/** A logged-in AppSignal user */
export type ViewerIncidentsArgs = {
  appId?: InputMaybe<Scalars['String']['input']>;
  assigneeIds?: InputMaybe<Array<Scalars['String']['input']>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<IncidentOrderEnum>;
  query?: InputMaybe<Scalars['String']['input']>;
  severity?: InputMaybe<IncidentSeverityEnum>;
  state?: InputMaybe<Array<IncidentStateEnum>>;
};

/** Visual object, used in dashboards. Can be timeseries. */
export type Visual = VisualTimeseries;

/**
 * Some data is better understood if the graph is rendered in a different way.
 * The following different types of different visuals are supported on dashboards.
 *
 * - LINE: Line graphs.
 * - AREA: Area graphs.
 * - AREA_RELATIVE: Relative area graphs.
 *
 * For more information see: https://docs.appsignal.com/metrics/dashboards.html
 *
 */
export enum VisualDisplayEnum {
  Area = 'AREA',
  AreaRelative = 'AREA_RELATIVE',
  Line = 'LINE'
}

/** An AppSignal visual, used on dashboards. */
export type VisualInterface = {
  /** Visual description */
  description?: Maybe<Scalars['String']['output']>;
  display?: Maybe<VisualDisplayEnum>;
  drawNullAsZero?: Maybe<Scalars['Boolean']['output']>;
  format?: Maybe<Scalars['String']['output']>;
  formatInput?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  /**
   * Customizable name for the line.
   * Support replacements for the metric names, fields and tags with %name%,
   * %field% and %tag% (where tag is the tag name you've specified).
   *
   * Defaults to %name%
   *
   */
  lineLabel?: Maybe<Scalars['String']['output']>;
  minYAxis?: Maybe<Scalars['Float']['output']>;
  /** Visual title */
  title: Scalars['String']['output'];
};

/** Timeseries visual, used on dashboard to show a timeseries graph. */
export type VisualTimeseries = VisualInterface & {
  __typename?: 'VisualTimeseries';
  /** Visual description */
  description?: Maybe<Scalars['String']['output']>;
  display?: Maybe<VisualDisplayEnum>;
  drawNullAsZero?: Maybe<Scalars['Boolean']['output']>;
  format?: Maybe<Scalars['String']['output']>;
  formatInput?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  /**
   * Customizable name for the line.
   * Support replacements for the metric names, fields and tags with %name%,
   * %field% and %tag% (where tag is the tag name you've specified).
   *
   * Defaults to %name%
   *
   */
  lineLabel?: Maybe<Scalars['String']['output']>;
  metrics: Array<VisualTimeseriesMetric>;
  minYAxis?: Maybe<Scalars['Float']['output']>;
  /** Visual title */
  title: Scalars['String']['output'];
};

export type VisualTimeseriesInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  display?: InputMaybe<VisualDisplayEnum>;
  drawNullAsZero?: InputMaybe<Scalars['Boolean']['input']>;
  format?: InputMaybe<Scalars['String']['input']>;
  formatInput?: InputMaybe<Scalars['String']['input']>;
  /**
   * Customizable name for the line.
   * Support replacements for the metric names, fields and tags with %name%,
   * %field% and %tag% (where tag is the tag name you've specified).
   *
   * Defaults to %name%
   *
   */
  lineLabel?: InputMaybe<Scalars['String']['input']>;
  metrics?: InputMaybe<Array<VisualTimeseriesMetricInput>>;
  minYAxis?: InputMaybe<Scalars['Float']['input']>;
  /** List of tags for the graph */
  tags?: InputMaybe<Array<TagInput>>;
  title: Scalars['String']['input'];
};

export type VisualTimeseriesMetric = {
  __typename?: 'VisualTimeseriesMetric';
  /** Metric fields */
  fields?: Maybe<Array<VisualTimeseriesMetricField>>;
  /** Metric name */
  name: Scalars['String']['output'];
  /** List of tags of the graph */
  tags?: Maybe<Array<KeyStringValue>>;
};

export type VisualTimeseriesMetricField = {
  __typename?: 'VisualTimeseriesMetricField';
  field?: Maybe<MetricFieldEnum>;
};

export type VisualTimeseriesMetricFieldInput = {
  field: MetricFieldEnum;
};

export type VisualTimeseriesMetricInput = {
  fields: Array<VisualTimeseriesMetricFieldInput>;
  name: Scalars['String']['input'];
  /** List of tags for the metric */
  tags?: InputMaybe<Array<TagInput>>;
};
